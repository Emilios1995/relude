<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Relude_Js_Promise (api.Relude_Js_Promise)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../">Up</a> – <a href="../">api</a> &#x00BB; Relude_Js_Promise</nav><h1>Module <code>Relude_Js_Promise</code></h1></header><dl><dt class="spec value" id="val-toIO"><a href="#val-toIO" class="anchor"></a><code><span class="keyword">let</span> toIO: a. Js.Promise.t(<span class="type-var">'a</span>) <span>=&gt;</span> Relude_IO.t<span>(<span class="type-var">'a</span>, Js.Promise.error)</span>;</code></dt><dd><p># Relude.Js.Promise</p><p>Utilities for interoperating with `Js.Promise`</p><p>Lifts a `Js.Promise` into a `Relude.IO`</p><p>Note: prefer `toIOLazy` over this function if possible. `Js.Promise`s are eagerly executed, so using `toIO` with an already-constructed and running `Js.Promise` will not suspend the side effects.</p></dd></dl><dl><dt class="spec value" id="val-toIOLazy"><a href="#val-toIOLazy" class="anchor"></a><code><span class="keyword">let</span> toIOLazy: a. <span>(unit <span>=&gt;</span> Js.Promise.t(<span class="type-var">'a</span>))</span> <span>=&gt;</span> Relude_IO.t<span>(<span class="type-var">'a</span>, Js.Promise.error)</span>;</code></dt><dd><p>Lifts a lazily-executed Js.Promise into a Relude.IO</p></dd></dl><dl><dt class="spec value" id="val-fromIOWithResult"><a href="#val-fromIOWithResult" class="anchor"></a><code><span class="keyword">let</span> fromIOWithResult: a e. Relude_IO.t<span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> Js.Promise.t(Pervasives.result<span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span>);</code></dt><dd><p>Converts a `Relude.IO` into a Js.Promise.t.</p><p>This function will cause the IO effects to be run.</p><p>The promise that is returned will not reject, it will instead have a `Result` as its resolution</p></dd></dl><dl><dt class="spec value" id="val-fromIO"><a href="#val-fromIO" class="anchor"></a><code><span class="keyword">let</span> fromIO: a e. Relude_IO.t<span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> Js.Promise.t(<span class="type-var">'a</span>);</code></dt><dd><p>Converts a `Relude.IO` into a Js.Promise.t.</p><p>This function will cause the IO effects to be run.</p><p>The error channel is unsafely coerced into the promise error type, which is probably fine, because the Js.Promise error type is opaque.</p></dd></dl><dl><dt class="spec value" id="val-fromIOExn"><a href="#val-fromIOExn" class="anchor"></a><code><span class="keyword">let</span> fromIOExn: a. Relude_IO.t<span>(<span class="type-var">'a</span>, exn)</span> <span>=&gt;</span> Js.Promise.t(<span class="type-var">'a</span>);</code></dt><dd><p>Converts a `Relude.IO` with an extensible OCaml exn as the error type into a Js.Promise.t.</p><p>This function will cause the IO effects to be run.</p></dd></dl><dl><dt class="spec value" id="val-fromIOJsExn"><a href="#val-fromIOJsExn" class="anchor"></a><code><span class="keyword">let</span> fromIOJsExn: a. Relude_IO.t<span>(<span class="type-var">'a</span>, Js.Exn.t)</span> <span>=&gt;</span> Js.Promise.t(<span class="type-var">'a</span>);</code></dt><dd><p>Converts a `Relude.IO` with a `Js.Exn.t` as the error type into a Js.Promise.t.</p><p>This function will cause the IO effects to be run.</p></dd></dl></div></body></html>