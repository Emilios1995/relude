<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Relude_IO (api.Relude_IO)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../">Up</a> – <a href="../">api</a> &#x00BB; Relude_IO</nav><h1>Module <code>Relude_IO</code></h1></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t('a, 'e)</code><code> = </code><table class="variant"><tr id="type-t.Pure" class="anchored"><td class="def constructor"><a href="#type-t.Pure" class="anchor"></a><code>| </code><code><span class="constructor">Pure</span>(<span class="type-var">'a</span>) : <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span></code></td></tr><tr id="type-t.Throw" class="anchored"><td class="def constructor"><a href="#type-t.Throw" class="anchor"></a><code>| </code><code><span class="constructor">Throw</span>(<span class="type-var">'e</span>) : <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span></code></td></tr><tr id="type-t.Suspend" class="anchored"><td class="def constructor"><a href="#type-t.Suspend" class="anchor"></a><code>| </code><code><span class="constructor">Suspend</span>(<span>(unit <span>=&gt;</span> <span class="type-var">'a</span>)</span>) : <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span></code></td></tr><tr id="type-t.SuspendIO" class="anchored"><td class="def constructor"><a href="#type-t.SuspendIO" class="anchor"></a><code>| </code><code><span class="constructor">SuspendIO</span>(<span>(unit <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span>)</span>) : <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span></code></td></tr><tr id="type-t.Async" class="anchored"><td class="def constructor"><a href="#type-t.Async" class="anchor"></a><code>| </code><code><span class="constructor">Async</span>(<span>(<span>(Pervasives.result<span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> unit)</span> <span>=&gt;</span> unit)</span>) : <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span></code></td></tr><tr id="type-t.Map" class="anchored"><td class="def constructor"><a href="#type-t.Map" class="anchor"></a><code>| </code><code><span class="constructor">Map</span>(<span>(<span class="type-var">'r</span> <span>=&gt;</span> <span class="type-var">'a</span>)</span>, <a href="#type-t">t</a><span>(<span class="type-var">'r</span>, <span class="type-var">'e</span>)</span>) : <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span></code></td></tr><tr id="type-t.Apply" class="anchored"><td class="def constructor"><a href="#type-t.Apply" class="anchor"></a><code>| </code><code><span class="constructor">Apply</span>(<a href="#type-t">t</a><span>(<span class="type-var">'r</span> <span>=&gt;</span> <span class="type-var">'a</span>, <span class="type-var">'e</span>)</span>, <a href="#type-t">t</a><span>(<span class="type-var">'r</span>, <span class="type-var">'e</span>)</span>) : <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span></code></td></tr><tr id="type-t.FlatMap" class="anchored"><td class="def constructor"><a href="#type-t.FlatMap" class="anchor"></a><code>| </code><code><span class="constructor">FlatMap</span>(<span>(<span class="type-var">'r</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span>)</span>, <a href="#type-t">t</a><span>(<span class="type-var">'r</span>, <span class="type-var">'e</span>)</span>) : <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span></code></td></tr></table>;</dt><dd><p>`Relude.IO` contains a type `t('a, 'e)` and related functions for representing and controlling the execution of side effects. A side effect is any application state change or behavior which can be observed outside a function other than its returned value. Side effects are basically where the &quot;work gets done&quot; in a program or application, but controlling when the side effects are executed makes your code more <code>pure</code>(https://en.wikipedia.org/wiki/Pure_function), easier to reason about, easier to reuse, and easier to safely and confidently refactor. This type is inspired by and based on the recent work that has gone into the concept of bi-functor IO in the FP community:</p><p>* John De Goes' blogs * <code>Bifunctor IO: A Step Away from Dynamically-Typed Error Handling</code>(http://degoes.net/articles/bifunctor-io) * <code>Beautiful, Simple, Testable Functional Effects for Scala</code>(http://degoes.net/articles/zio-environment) * <code>ZIO</code>(https://github.com/scalaz/scalaz-zio) * <code>cats-bio</code>(https://github.com/LukaJCB/cats-bio) * <code>PureScript Aff Discussion</code>(https://github.com/slamdata/purescript-aff/issues/137)</p><p>`IO` can represent any type of synchronous or asynchronous side effect that can either produce a value (in the success channel `'a`) or an error (in the error channel `'e`). The main purpose of `IO` is to make side-effectful code <code>referentially transparent</code>(https://en.wikipedia.org/wiki/Referential_transparency) and to allow you to control when side effects are executed or &quot;run.&quot; When you construct an `IO`, in most cases you are just suspending the execution of a side effect, rather than allowing it to execute immediately. In the case of a synchronous effect like a `console.log(...)`, which writes to the console, or `Date.now()`, which reads the current clock time from the system, or `Math.random()`, which generates a random number out of the blue, it simply makes the action lazy, using a thunk like `unit =&gt; effect`. In the case of asynchronous side effects, it suspends the start of execution of the asynchronous action until the `IO` is run. There is no magic with `IO` - it simply &quot;holds onto&quot; effects in a suspended state (e.g. a thunk `unit =&gt; 'a`)) until you run the `IO` using `unsafeRunAsync`. Because `IO` can represent both synchronous and asynchronous side effects, the end result of executing an `IO` (`unsafeRunAsync`) is asynchronous (i.e. the value or error is given to the caller via an async callback).</p><p>### Why is running an `IO` considered unsafe?</p><p>An `IO` value represents a &quot;description&quot; or &quot;recipe&quot; of one or more side effects to perform. When you run an `IO`, all of the suspended effects are executed, and all of the side effects will occur. Naming the run function `unsafeRunAsync` is intended to warn you that invoking the function will execute your side effects. Describing these functions as &quot;unsafe&quot; is a convention in the FP community for performing `IO` effects - see <code>Haskell IO</code>(http://hackage.haskell.org/package/base-4.12.0.0/docs/System-IO-Unsafe.html), <code>Purescript Effect</code>(https://pursuit.purescript.org/packages/purescript-effect/2.0.1/docs/Effect.Unsafe#v:unsafePerformEffect), <code>Cats Effect IO</code>(https://typelevel.org/cats-effect/datatypes/io.html#unsafe-operations).</p><p>### Relation to `Js.Promise`</p><p>If you are coming from the JavaScript world, don't be afraid of `IO` - in many ways, you can basically just think of it as a construct similar to `Promise`, with the following key differences:</p><p>1. `Promise` is eagerly-executed and `IO` is lazily-executed. When you construct a `Promise` its execution is immediately started, and it will invoke it's success or failure callbacks whenever it finishes. `IO` is lazily-executed, so it will not do anything until you &quot;run&quot; the `IO` using `unsafeRunAsync`, which provides you with the resulting value or error using a callback from `result('a, 'e) =&gt; unit`. Just think of `IO` as something like a `Promise`, but instead of starting it by constructing it, you explicitly start it later on by calling `unsafeRunAsync`. 1. `Promise` <code>memoizes</code>(https://en.wikipedia.org/wiki/Memoization) its result value, and `IO` does not. This means that once a `Promise` is resolved or rejected, it will hold onto the resulting value or error, and any future uses of `then` or `catch` will produce that same value or error, rather than re-running the `Promise` and producing a new value or error. `IO` doesn't have built-in memoization of the value, so re-running an `IO` will cause all the effects to be re-run, and a new value (or error) will be produced. 1. A `Promise` can fail (be rejected) with any type of value, and in JavaScript, the only way to tell what type of error occurred is to inspect the error value and/or its type at runtime. When translated to the ReasonML world, this means that the error type produced by `Js.Promise` can't be known at compile time, so is simply represented by a completely <code>opaque type</code>(https://bucklescript.github.io/bucklescript/api/Js.Promise.html#TYPEerror). This makes error handling a runtime coercion problem, rather than a compile time problem. Because `Promise` can fail with any type of error, you can think of a `Promise` as having an implicit error type like an `any` type - it can fail with any type of error. If you've ever worked with a language that has an `any` type, you've probably experienced some pain in dealing with those types of values. On the other hand, `IO.t('a, 'e)` represents the error as an explicit type, which you can control and manipulate at compile time. This gives you the freedom to represent an error in the most appropriate way for each scenario. In some scenarios you may not care what the error is, you just care whether the operation failed, so you could use the equivalent of the `Js.Promise` opaque error type, or even `unit` as the error type. In cases where you do care what types of errors can occur, and want to handle them, you can use your own variant type, a custom error type, or whatever makes the most sense for your use case. There is no silver bullet in figuring out what type to use for the error, but having the flexibility to choose makes error handling much easier than dealing with runtime coercions and trying to guess what types of errors might occur, and how to catch them.</p><p>### More about &quot;effects&quot;</p><p>The word &quot;effect&quot; is a bit overloaded in the functional programming world. We often hear about &quot;side effects,&quot; and this term is typically referring to things like writing to stdout, making a network call, getting the system time, generating a random number using something like JavaScript's `Math.random` - these are all things that either send information to the outside world, or pull information in from the outside world. They are called &quot;side effects&quot; because the function has an effect on the system beyond its input arguments and output return value - it does something that is not represented by the input and output types.</p><p>Another place in functional programming where the term &quot;effect&quot; appears is when we talk about data types like `option('a)` or `result('a, 'e)` - these types of values are often called &quot;effectful&quot; values, because they represent some sort of additional &quot;effect&quot; that may have occurred (note: we're not talking about &quot;side effects&quot; in the above sense). For example if you have a function `a =&gt; b`, assuming it's a pure function that doesn't throw exceptions, the only possible value you can get out of the function is a value of type `'b` - there's no way to represent a failure, an asynchronous computation, or a case where the function can't produce a value. If instead the function is `'a =&gt; option('b)`, the function can now either produce a value of type `'a`, or fail to produce a value (`None`). This behavior is often called the &quot;effect&quot; of producing a value with the possibility of not being able to produce a value. For `'a =&gt; result('b, 'e)`, we have the &quot;effect&quot; of either producing a value or an error. `Js.Promise` is another effectful value in that it has the &quot;effect&quot; of asynchronous computation (a value will be produced at some time later), and the &quot;effect&quot; of possible failure. In terms of `IO`, this is important because not only can `IO` suspend actual &quot;side effects&quot; (like stdout/network/etc.), but it can also represent the types of &quot;effects&quot; like `option('a)`, `result('a, 'e)`, `Js.Promise.t`, etc. All of these types of &quot;effectful&quot; values can be converted to an `IO`, so that you can easily compose all of these different effects in a single expression. When you try to write code in the monadic style (e.g. using chained `bind`/`flatMap`/`&gt;&gt;=` operations), it can be quite convenient to be able to deal with various types of side effects and &quot;functional effects&quot; using a single Monad.</p><p>IO is a bi-functor effect type that supports both synchronous and asynchronous effects, with explicit error handling.</p><p>This is inspired by the following libraries/articles:</p><p>* John De Goes - http://degoes.net/articles/only-one-io and http://degoes.net/articles/bifunctor-io * ZIO/Scalaz 8 IO (Scala) - https://github.com/scalaz/scalaz-zio * cats-bio (Scala) - https://github.com/LukaJCB/cats-bio * purescript-aff discussion (Purescript) - https://github.com/slamdata/purescript-aff/issues/137</p></dd></dl><dl><dt class="spec value" id="val-pure"><a href="#val-pure" class="anchor"></a><code><span class="keyword">let</span> pure: a e. <span class="type-var">'a</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span>;</code></dt><dd><p>Wraps a strictly-evaluated value in an `IO`</p><p>Prefer `suspend` (or variants) for values that are expensive to construct or may have side-effects.</p></dd></dl><dl><dt class="spec value" id="val-pureWithVoid"><a href="#val-pureWithVoid" class="anchor"></a><code><span class="keyword">let</span> pureWithVoid: a. <span class="type-var">'a</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, Relude_Void.t)</span>;</code></dt><dd><p>Wraps a non-failing, strictly-evaluated value in an `IO`</p><p>Prefer `suspend` for values that are expensive to construct or may have side-effects.</p></dd></dl><dl><dt class="spec value" id="val-unit"><a href="#val-unit" class="anchor"></a><code><span class="keyword">let</span> unit: e. <a href="#type-t">t</a><span>(unit, <span class="type-var">'e</span>)</span>;</code></dt><dd><p>Wraps a strictly-evaluated unit value `()` in an `IO`</p></dd></dl><dl><dt class="spec value" id="val-unitWithVoid"><a href="#val-unitWithVoid" class="anchor"></a><code><span class="keyword">let</span> unitWithVoid: <a href="#type-t">t</a><span>(unit, Relude_Void.t)</span>;</code></dt><dd><p>Wraps a non-failing, strictly-evaluated unit value `()` in an `IO`</p></dd></dl><dl><dt class="spec value" id="val-throw"><a href="#val-throw" class="anchor"></a><code><span class="keyword">let</span> throw: a e. <span class="type-var">'e</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span>;</code></dt><dd><p>Wraps a strictly-evaluated error value in an `IO`</p><p>Prefer `suspendThrow` (or variants) for values that are expensive to construct or may have side-effects.</p></dd></dl><dl><dt class="spec value" id="val-throwWithVoid"><a href="#val-throwWithVoid" class="anchor"></a><code><span class="keyword">let</span> throwWithVoid: e. <span class="type-var">'e</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(Relude_Void.t, <span class="type-var">'e</span>)</span>;</code></dt><dd><p>Wraps a non-succeeding, strictly-evaluated error value in an `IO`</p></dd></dl><dl><dt class="spec value" id="val-suspend"><a href="#val-suspend" class="anchor"></a><code><span class="keyword">let</span> suspend: a e. <span>(unit <span>=&gt;</span> <span class="type-var">'a</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span>;</code></dt><dd><p>Wraps a lazily-evaluated value in an `IO`</p></dd></dl><dl><dt class="spec value" id="val-suspendWithVoid"><a href="#val-suspendWithVoid" class="anchor"></a><code><span class="keyword">let</span> suspendWithVoid: a. <span>(unit <span>=&gt;</span> <span class="type-var">'a</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, Relude_Void.t)</span>;</code></dt><dd><p>Wraps a non-failing, lazily-evaluated value in an `IO`</p></dd></dl><dl><dt class="spec value" id="val-suspendThrow"><a href="#val-suspendThrow" class="anchor"></a><code><span class="keyword">let</span> suspendThrow: a e. <span>(unit <span>=&gt;</span> <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span>;</code></dt><dd><p>Wraps a lazily-evaluated error in an `IO`</p></dd></dl><dl><dt class="spec value" id="val-suspendIO"><a href="#val-suspendIO" class="anchor"></a><code><span class="keyword">let</span> suspendIO: a e. <span>(unit <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span>;</code></dt><dd><p>Wraps a lazily-evaluated `IO` value in an `IO`</p><p>This can be useful if you are dealing with an effectful value that is normally eagerly or strictly evaluated, like a `Result`/`option`/`Js.Promise`/etc. In this case, you would typically convert the effectful value into an `IO` using one of the other functions in `IO` like `pure` or `throw`, but doing this strict conversion inside a `suspendIO` function makes the conversion lazy.</p></dd></dl><dl><dt class="spec value" id="val-async"><a href="#val-async" class="anchor"></a><code><span class="keyword">let</span> async: a e. <span>(<span>(Pervasives.result<span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> unit)</span> <span>=&gt;</span> unit)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span>;</code></dt><dd><p>Creates an async `IO` value that is run by invoking a callback `Result.t('a, 'e) =&gt; unit`</p><p>This is useful for lifting other types of async effects into `IO`, like `Js.Promise` or a Node.js-style callback API.</p></dd></dl><dl><dt class="spec value" id="val-fromOption"><a href="#val-fromOption" class="anchor"></a><code><span class="keyword">let</span> fromOption: a e. <span>(unit <span>=&gt;</span> <span class="type-var">'e</span>)</span> <span>=&gt;</span> option(<span class="type-var">'a</span>) <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span>;</code></dt><dd><p>Converts an `option('a)` to an `IO.t('a, 'e) by providing a callback to use when the `option` is `None`</p><p>Because the option is already evaluated, no effort is made to suspend any effects.</p></dd></dl><dl><dt class="spec value" id="val-fromResult"><a href="#val-fromResult" class="anchor"></a><code><span class="keyword">let</span> fromResult: a e. Pervasives.result<span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span>;</code></dt><dd><p>Converts an `Result.t('a, 'e)` to an `IO.t('a, 'e)</p><p>Because the result is already evaluated, no effort is made to suspend any effects.</p></dd></dl><dl><dt class="spec value" id="val-map"><a href="#val-map" class="anchor"></a><code><span class="keyword">let</span> map: a b e. <span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'b</span>, <span class="type-var">'e</span>)</span>;</code></dt><dd><p>Applies a function `a =&gt; `b on an `IO.t('a, 'e)` to produce an `IO.t('b, 'e)`</p></dd></dl><dl><dt class="spec value" id="val-(&lt;$&gt;)"><a href="#val-(&lt;$&gt;)" class="anchor"></a><code><span class="keyword">let</span> (&lt;$&gt;): <span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'c</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'b</span>, <span class="type-var">'c</span>)</span>;</code></dt><dt class="spec value" id="val-(&lt;#&gt;)"><a href="#val-(&lt;#&gt;)" class="anchor"></a><code><span class="keyword">let</span> (&lt;#&gt;): <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <span>=&gt;</span> <span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'c</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'c</span>, <span class="type-var">'b</span>)</span>;</code></dt><dt class="spec value" id="val-tap"><a href="#val-tap" class="anchor"></a><code><span class="keyword">let</span> tap: a e. <span>(<span class="type-var">'a</span> <span>=&gt;</span> unit)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span>;</code></dt><dd><p>Applies a side-effect function ``a =&gt; unit` on an `IO.t('a, 'e)`, and propagates the `'a` value unchanged.</p><p>This is useful for doing things like logging the value inside the `IO`.</p></dd></dl><dl><dt class="spec value" id="val-apply"><a href="#val-apply" class="anchor"></a><code><span class="keyword">let</span> apply: a b e. <a href="#type-t">t</a><span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'b</span>, <span class="type-var">'e</span>)</span>;</code></dt><dd><p>Applicative `apply` function</p></dd></dl><dl><dt class="spec value" id="val-(&lt;*&gt;)"><a href="#val-(&lt;*&gt;)" class="anchor"></a><code><span class="keyword">let</span> (&lt;*&gt;): <a href="#type-t">t</a><span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span>, <span class="type-var">'c</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'c</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'b</span>, <span class="type-var">'c</span>)</span>;</code></dt><dt class="spec value" id="val-flatMap"><a href="#val-flatMap" class="anchor"></a><code><span class="keyword">let</span> flatMap: a b e. <span>(<span class="type-var">'a</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'b</span>, <span class="type-var">'e</span>)</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'b</span>, <span class="type-var">'e</span>)</span>;</code></dt><dd><p>Applies an effectful function `'a =&gt; IO.t('b, 'e)` on the `'a` value inside the `IO` to produce an `IO.t('b, 'e)`</p></dd></dl><dl><dt class="spec value" id="val-bind"><a href="#val-bind" class="anchor"></a><code><span class="keyword">let</span> bind: a b e. <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <span>(<span class="type-var">'a</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'b</span>, <span class="type-var">'e</span>)</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'b</span>, <span class="type-var">'e</span>)</span>;</code></dt><dd><p>Same as `flatMap`, but with the argument order reversed. Also an alias for the `&gt;&gt;=` &quot;bind&quot; operator.</p></dd></dl><dl><dt class="spec value" id="val-(&gt;&gt;=)"><a href="#val-(&gt;&gt;=)" class="anchor"></a><code><span class="keyword">let</span> (&gt;&gt;=): <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <span>=&gt;</span> <span>(<span class="type-var">'a</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'c</span>, <span class="type-var">'b</span>)</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'c</span>, <span class="type-var">'b</span>)</span>;</code></dt><dt class="spec value" id="val-cond"><a href="#val-cond" class="anchor"></a><code><span class="keyword">let</span> cond: a e. <span>(<span class="type-var">'a</span> <span>=&gt;</span> bool)</span> <span>=&gt;</span> <span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'e</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span>;</code></dt><dd><p>Conditional map. If the condition is satisfied, return the given `'a` in lifted into a successful IO, otherwise, return the given `e` Lifted to the error side.</p></dd></dl><dl><dt class="spec value" id="val-condError"><a href="#val-condError" class="anchor"></a><code><span class="keyword">let</span> condError: a e. <span>(<span class="type-var">'a</span> <span>=&gt;</span> bool)</span> <span>=&gt;</span> <span class="type-var">'e</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span>;</code></dt><dd><p>As `cond`, but only maps the 'e side when the condition fails.</p></dd></dl><dl><dt class="spec value" id="val-unsafeRunAsync"><a href="#val-unsafeRunAsync" class="anchor"></a><code><span class="keyword">let</span> unsafeRunAsync: a e. <span>(Pervasives.result<span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> unit)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> unit;</code></dt><dd><p>Unsafely runs the `IO.t('a, 'e)` to produce a final `Result.t('a, 'e)`, which is provided to the caller via a callback of type `Result.t('a, 'e) =&gt; unit`.</p><p>This function should be run &quot;at the end of the world&quot; to evaluate the suspended side-effects in the `IO` and produce either an error of type `'e` or a successful value of type `'a`. Ideally in simple apps, the &quot;end of the world&quot; is the end of your main function, but when using `IO` inside existing frameworks that don't natively support `IO`, the &quot;end of the world&quot; might be the context of a reducer side effect, or a web app controller function.</p><p>The function uses the term &quot;unsafe&quot; because calling this function causes all of the suspended side effects to actually be executed. It is not &quot;unsafe&quot; in that it can throw an exception - it is just a convention in FP libraries to denote these types of functions as unsafe.</p></dd></dl><dl><dt class="spec value" id="val-unsafeRunAsyncPar2"><a href="#val-unsafeRunAsyncPar2" class="anchor"></a><code><span class="keyword">let</span> unsafeRunAsyncPar2: a b e. <span>(Pervasives.result<span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> Pervasives.result<span>(<span class="type-var">'b</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> unit)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'b</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> unit;</code></dt><dd><p>* Runs two IOs in parallel, and invokes the given done callback when all complete * * Note that applicative uses of IO (apply/map2/map3/traverse/etc.) will run * the IOs in parallel, so it's rarely necessary for the end-user to call this * directly.</p></dd></dl><dl><dt class="spec value" id="val-unsafeRunAsyncPar3"><a href="#val-unsafeRunAsyncPar3" class="anchor"></a><code><span class="keyword">let</span> unsafeRunAsyncPar3: a b c e. <span>(Pervasives.result<span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> Pervasives.result<span>(<span class="type-var">'b</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> Pervasives.result<span>(<span class="type-var">'c</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> unit)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'b</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'c</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> unit;</code></dt><dd><p>* Runs three IOs in parallel, and invokes the given done callback when all complete * * Note that applicative uses of IO (apply/map2/map3/traverse/etc.) will run * the IOs in parallel, so it's rarely necessary for the end-user to call this * directly.</p></dd></dl><dl><dt class="spec value" id="val-compose"><a href="#val-compose" class="anchor"></a><code><span class="keyword">let</span> compose: a b c e. <a href="#type-t">t</a><span>(<span class="type-var">'b</span> <span>=&gt;</span> <span class="type-var">'c</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'c</span>, <span class="type-var">'e</span>)</span>;</code></dt><dd><p>* Creates a new IO value that contains the composition of functions from two * input IO values. Composition is done from right-to-left with this function - see * andThen for left-to-right.</p></dd></dl><dl><dt class="spec value" id="val-composePure"><a href="#val-composePure" class="anchor"></a><code><span class="keyword">let</span> composePure: a b c e. <span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'b</span> <span>=&gt;</span> <span class="type-var">'c</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'c</span>, <span class="type-var">'e</span>)</span>;</code></dt><dd><p>* compose specialization for a left-hand-side Pure('a =&gt; 'b)</p></dd></dl><dl><dt class="spec value" id="val-composeThrow"><a href="#val-composeThrow" class="anchor"></a><code><span class="keyword">let</span> composeThrow: a b c e. <span class="type-var">'e</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'b</span> <span>=&gt;</span> <span class="type-var">'c</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'c</span>, <span class="type-var">'e</span>)</span>;</code></dt><dd><p>* compose specialization for a left-hand-side Throw</p></dd></dl><dl><dt class="spec value" id="val-composeSuspend"><a href="#val-composeSuspend" class="anchor"></a><code><span class="keyword">let</span> composeSuspend: a b c e. <span>(unit <span>=&gt;</span> <span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'b</span> <span>=&gt;</span> <span class="type-var">'c</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'c</span>, <span class="type-var">'e</span>)</span>;</code></dt><dd><p>* compose specialization for a left-hand-side Suspend</p></dd></dl><dl><dt class="spec value" id="val-composeSuspendIO"><a href="#val-composeSuspendIO" class="anchor"></a><code><span class="keyword">let</span> composeSuspendIO: a b c e. <span>(unit <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span>, <span class="type-var">'e</span>)</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'b</span> <span>=&gt;</span> <span class="type-var">'c</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'c</span>, <span class="type-var">'e</span>)</span>;</code></dt><dd><p>* compose specialization for a left-hand-side SuspendIO</p></dd></dl><dl><dt class="spec value" id="val-composeAsync"><a href="#val-composeAsync" class="anchor"></a><code><span class="keyword">let</span> composeAsync: a b c e. <span>(<span>(Pervasives.result<span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> unit)</span> <span>=&gt;</span> unit)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'b</span> <span>=&gt;</span> <span class="type-var">'c</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'c</span>, <span class="type-var">'e</span>)</span>;</code></dt><dd><p>* compose specialization for a left-hand-side Async</p></dd></dl><dl><dt class="spec value" id="val-composeMap"><a href="#val-composeMap" class="anchor"></a><code><span class="keyword">let</span> composeMap: a b c r0 e. <span>(<span class="type-var">'r0</span> <span>=&gt;</span> <span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'r0</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'b</span> <span>=&gt;</span> <span class="type-var">'c</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'c</span>, <span class="type-var">'e</span>)</span>;</code></dt><dd><p>* compose specialization for a left-hand-side Map</p></dd></dl><dl><dt class="spec value" id="val-composeApply"><a href="#val-composeApply" class="anchor"></a><code><span class="keyword">let</span> composeApply: a b c r0 e. <a href="#type-t">t</a><span>(<span class="type-var">'r0</span> <span>=&gt;</span> <span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'r0</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'b</span> <span>=&gt;</span> <span class="type-var">'c</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'c</span>, <span class="type-var">'e</span>)</span>;</code></dt><dd><p>* compose specialization for a left-hand-side Apply</p></dd></dl><dl><dt class="spec value" id="val-composeFlatMap"><a href="#val-composeFlatMap" class="anchor"></a><code><span class="keyword">let</span> composeFlatMap: a b c r0 e. <span>(<span class="type-var">'r0</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span>, <span class="type-var">'e</span>)</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'r0</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'b</span> <span>=&gt;</span> <span class="type-var">'c</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'c</span>, <span class="type-var">'e</span>)</span>;</code></dt><dd><p>* compose specialization for a left-hand-side FlatMap</p></dd></dl><dl><dt class="spec value" id="val-(&lt;&lt;&lt;)"><a href="#val-(&lt;&lt;&lt;)" class="anchor"></a><code><span class="keyword">let</span> (&lt;&lt;&lt;): <a href="#type-t">t</a><span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span>, <span class="type-var">'c</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'d</span> <span>=&gt;</span> <span class="type-var">'a</span>, <span class="type-var">'c</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'d</span> <span>=&gt;</span> <span class="type-var">'b</span>, <span class="type-var">'c</span>)</span>;</code></dt><dd><p>* Operator for IO's compose right-to-left composition function * * (using triple &lt;&lt;&lt; to disambiguate from function compose &lt;&lt;)</p></dd></dl><dl><dt class="spec value" id="val-andThen"><a href="#val-andThen" class="anchor"></a><code><span class="keyword">let</span> andThen: a b c e. <a href="#type-t">t</a><span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'b</span> <span>=&gt;</span> <span class="type-var">'c</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'c</span>, <span class="type-var">'e</span>)</span>;</code></dt><dd><p>* Flipped version of compose for left-to-right usage</p></dd></dl><dl><dt class="spec value" id="val-(&gt;&gt;&gt;)"><a href="#val-(&gt;&gt;&gt;)" class="anchor"></a><code><span class="keyword">let</span> (&gt;&gt;&gt;): <a href="#type-t">t</a><span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span>, <span class="type-var">'c</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'b</span> <span>=&gt;</span> <span class="type-var">'d</span>, <span class="type-var">'c</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'d</span>, <span class="type-var">'c</span>)</span>;</code></dt><dd><p>* Operator for IO's andThen left-to-right composition function * * (using triple &gt;&gt;&gt; to disambiguate from function andThen &gt;&gt;)</p></dd></dl><dl><dt class="spec value" id="val-mapError"><a href="#val-mapError" class="anchor"></a><code><span class="keyword">let</span> mapError: a e1 e2. <span>(<span class="type-var">'e1</span> <span>=&gt;</span> <span class="type-var">'e2</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e1</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e2</span>)</span>;</code></dt><dd><p>Same as `map`, but operates on the error channel.</p></dd></dl><dl><dt class="spec value" id="val-tapError"><a href="#val-tapError" class="anchor"></a><code><span class="keyword">let</span> tapError: a e. <span>(<span class="type-var">'e</span> <span>=&gt;</span> unit)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span>;</code></dt><dd><p>Same as `tap`, but operates on the error channel.</p></dd></dl><dl><dt class="spec value" id="val-catchError"><a href="#val-catchError" class="anchor"></a><code><span class="keyword">let</span> catchError: a e1 e2. <span>(<span class="type-var">'e1</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e2</span>)</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e1</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e2</span>)</span>;</code></dt><dd><p>Handles an error of types `'e1` from an `IO.t('a, 'e1)` and converts it into a new `IO.t('a, 'e1)` value. This is much like `flatMap`/`bind` but works for the error channel of the `IO`.</p></dd></dl><dl><dt class="spec value" id="val-catchErrorMap"><a href="#val-catchErrorMap" class="anchor"></a><code><span class="keyword">let</span> catchErrorMap: a r0 e1 e2. <span>(<span class="type-var">'e1</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e2</span>)</span>)</span> <span>=&gt;</span> <span>(<span class="type-var">'r0</span> <span>=&gt;</span> <span class="type-var">'a</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'r0</span>, <span class="type-var">'e1</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e2</span>)</span>;</code></dt><dt class="spec value" id="val-catchErrorApply"><a href="#val-catchErrorApply" class="anchor"></a><code><span class="keyword">let</span> catchErrorApply: a r0 e1 e2. <span>(<span class="type-var">'e1</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e2</span>)</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'r0</span> <span>=&gt;</span> <span class="type-var">'a</span>, <span class="type-var">'e1</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'r0</span>, <span class="type-var">'e1</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e2</span>)</span>;</code></dt><dt class="spec value" id="val-catchErrorFlatMap"><a href="#val-catchErrorFlatMap" class="anchor"></a><code><span class="keyword">let</span> catchErrorFlatMap: a r0 e1 e2. <span>(<span class="type-var">'e1</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e2</span>)</span>)</span> <span>=&gt;</span> <span>(<span class="type-var">'r0</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e1</span>)</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'r0</span>, <span class="type-var">'e1</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e2</span>)</span>;</code></dt><dt class="spec value" id="val-handleError"><a href="#val-handleError" class="anchor"></a><code><span class="keyword">let</span> handleError: a e. <span>(<span class="type-var">'e</span> <span>=&gt;</span> <span class="type-var">'a</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, Relude_Void.t)</span>;</code></dt><dd><p>* Uses a function to convert an error value to a success value, which serves to &quot;clear&quot; the error * in the IO, thereby making the error type `Void.t`.</p></dd></dl><dl><dt class="spec value" id="val-mapHandleError"><a href="#val-mapHandleError" class="anchor"></a><code><span class="keyword">let</span> mapHandleError: a e b. <span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span>)</span> <span>=&gt;</span> <span>(<span class="type-var">'e</span> <span>=&gt;</span> <span class="type-var">'b</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'b</span>, Relude_Void.t)</span>;</code></dt><dd><p>* Maps the success channel and handles an error on the error channel to end up with an * IO of a new type with a voided error channel</p></dd></dl><dl><dt class="spec value" id="val-bimap"><a href="#val-bimap" class="anchor"></a><code><span class="keyword">let</span> bimap: a b e1 e2. <span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span>)</span> <span>=&gt;</span> <span>(<span class="type-var">'e1</span> <span>=&gt;</span> <span class="type-var">'e2</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e1</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'b</span>, <span class="type-var">'e2</span>)</span>;</code></dt><dd><p>Applies functions on both the success and error channels of the `IO`.</p></dd></dl><dl><dt class="spec value" id="val-bitap"><a href="#val-bitap" class="anchor"></a><code><span class="keyword">let</span> bitap: a e. <span>(<span class="type-var">'a</span> <span>=&gt;</span> unit)</span> <span>=&gt;</span> <span>(<span class="type-var">'e</span> <span>=&gt;</span> unit)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span>;</code></dt><dd><p>Same as `tap`, but works on both the success and error channels simultaneously.</p></dd></dl><dl><dt class="spec value" id="val-alt"><a href="#val-alt" class="anchor"></a><code><span class="keyword">let</span> alt: a e. <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span>;</code></dt><dd><p>* Returns a new `IO` that when run, will attempt the `IO` given as the first argument, * and if it fails, will attempt the `IO` given as the second argument. The second `IO` * is only run if the first fails. * * The &lt;|&gt; operator version of `alt` can be accessed via the `IO.WithError` module functor, * like this: * * ```reason * module IOE = IO.WithError(<code> type t = string; </code>); * * let a = ref(false); * let b = ref(false); * * IOE.Infix.( * IO.suspend(() =&gt; a := true) * &lt;|&gt; IO.suspend(() =&gt; b := true) // this effect won't run in this case, because the previous IO succeeds * |&gt; IO.unsafeRunAsync(...) * ); * ```</p></dd></dl><dl><dt class="spec value" id="val-align"><a href="#val-align" class="anchor"></a><code><span class="keyword">let</span> align: a b e. <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'b</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(Relude_Ior_Type.t<span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span>, <span class="type-var">'e</span>)</span>;</code></dt><dd><p>* Creates a new IO that will run the two input IO effects in parallel, and resolve if either or both succeed.</p></dd></dl><dl><dt class="spec value" id="val-alignWith"><a href="#val-alignWith" class="anchor"></a><code><span class="keyword">let</span> alignWith: a b c e. <span>(Relude_Ior_Type.t<span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <span>=&gt;</span> <span class="type-var">'c</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'b</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'c</span>, <span class="type-var">'e</span>)</span>;</code></dt><dd><p>* Creates a new IO that runs two effects in parallel, and if either or both succeed, convert the result into another type 'c</p></dd></dl><dl><dt class="spec value" id="val-orElse"><a href="#val-orElse" class="anchor"></a><code><span class="keyword">let</span> orElse: a e. <span>fallback:<a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span></span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span>;</code></dt><dd><p>* Returns a new `IO` that when run, will attempt the `IO` given as the second, un-labeled argument, * and if it fails, will attempt the `IO` given as the first argument with the label ~fallback. * * This is intended to be used with the `|&gt;` pipe operator, like this: * * ```reason * IO.suspend(() =&gt; a := true) * |&gt; IO.orElse(~fallback=IO.suspend(() =&gt; b := true)) * |&gt; IO.unsafeRunAsync(...) * ```</p></dd></dl><dl><dt class="spec value" id="val-tries"><a href="#val-tries" class="anchor"></a><code><span class="keyword">let</span> tries: a. <span>(unit <span>=&gt;</span> <span class="type-var">'a</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, exn)</span>;</code></dt><dd><p>Lifts a side-effect function that might throw an exception into a suspended `IO.t('a, exn)` value.</p><p>The `exn` type is OCaml's extensible error type.</p></dd></dl><dl><dt class="spec value" id="val-triesJS"><a href="#val-triesJS" class="anchor"></a><code><span class="keyword">let</span> triesJS: a. <span>(unit <span>=&gt;</span> <span class="type-var">'a</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, Js.Exn.t)</span>;</code></dt><dd><p>Lifts a side-effect function that might throw an JS exception into a suspended `IO.t('a, Js.Exn.t)` value.</p><p>If a normal `Js.Exn.t` is throw, it is captured as-is, but if the thrown object is not a `Js.Exn.t` it is unsafely coerced into a `Js.Exn.t`.</p></dd></dl><dl><dt class="spec value" id="val-flip"><a href="#val-flip" class="anchor"></a><code><span class="keyword">let</span> flip: a e. <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'e</span>, <span class="type-var">'a</span>)</span>;</code></dt><dd><p>Flips the values between the success and error channels.</p></dd></dl><dl><dt class="spec value" id="val-flipMap"><a href="#val-flipMap" class="anchor"></a><code><span class="keyword">let</span> flipMap: a r0 e. <span>(<span class="type-var">'r0</span> <span>=&gt;</span> <span class="type-var">'a</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'r0</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'e</span>, <span class="type-var">'a</span>)</span>;</code></dt><dt class="spec value" id="val-flipApply"><a href="#val-flipApply" class="anchor"></a><code><span class="keyword">let</span> flipApply: a r0 e. <a href="#type-t">t</a><span>(<span class="type-var">'r0</span> <span>=&gt;</span> <span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'r0</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'e</span>, <span class="type-var">'a</span>)</span>;</code></dt><dt class="spec value" id="val-flipFlatMap"><a href="#val-flipFlatMap" class="anchor"></a><code><span class="keyword">let</span> flipFlatMap: a r0 e. <span>(<span class="type-var">'r0</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'r0</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'e</span>, <span class="type-var">'a</span>)</span>;</code></dt><dt class="spec value" id="val-summonError"><a href="#val-summonError" class="anchor"></a><code><span class="keyword">let</span> summonError: a e. <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(Pervasives.result<span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span>, Relude_Void.t)</span>;</code></dt><dd><p>Summons an error of type `'e` from the error channel into the success channel as a `Result.t('a, 'e)`. The error channel becomes `Void.t` because the error has been (re)moved.</p></dd></dl><dl><dt class="spec value" id="val-summonErrorMap"><a href="#val-summonErrorMap" class="anchor"></a><code><span class="keyword">let</span> summonErrorMap: a r0 e. <span>(<span class="type-var">'r0</span> <span>=&gt;</span> <span class="type-var">'a</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'r0</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(Pervasives.result<span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span>, Relude_Void.t)</span>;</code></dt><dt class="spec value" id="val-summonErrorApply"><a href="#val-summonErrorApply" class="anchor"></a><code><span class="keyword">let</span> summonErrorApply: a r0 e. <a href="#type-t">t</a><span>(<span class="type-var">'r0</span> <span>=&gt;</span> <span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'r0</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(Pervasives.result<span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span>, Relude_Void.t)</span>;</code></dt><dt class="spec value" id="val-summonErrorFlatMap"><a href="#val-summonErrorFlatMap" class="anchor"></a><code><span class="keyword">let</span> summonErrorFlatMap: a r0 e. <span>(<span class="type-var">'r0</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'r0</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(Pervasives.result<span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span>, Relude_Void.t)</span>;</code></dt><dt class="spec value" id="val-unsummonError"><a href="#val-unsummonError" class="anchor"></a><code><span class="keyword">let</span> unsummonError: a e. <a href="#type-t">t</a><span>(Pervasives.result<span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span>, Relude_Void.t)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span>;</code></dt><dd><p>Unsummons an error from a success channel `Result.t('a, 'e)` back into the error channel of the `IO`.</p></dd></dl><dl><dt class="spec value" id="val-unsummonErrorMap"><a href="#val-unsummonErrorMap" class="anchor"></a><code><span class="keyword">let</span> unsummonErrorMap: r0 a e. <span>(<span class="type-var">'r0</span> <span>=&gt;</span> Pervasives.result<span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'r0</span>, Relude_Void.t)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span>;</code></dt><dt class="spec value" id="val-unsummonErrorApply"><a href="#val-unsummonErrorApply" class="anchor"></a><code><span class="keyword">let</span> unsummonErrorApply: r0 a e. <a href="#type-t">t</a><span>(<span class="type-var">'r0</span> <span>=&gt;</span> Pervasives.result<span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span>, Relude_Void.t)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'r0</span>, Relude_Void.t)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span>;</code></dt><dt class="spec value" id="val-unsummonErrorFlatMap"><a href="#val-unsummonErrorFlatMap" class="anchor"></a><code><span class="keyword">let</span> unsummonErrorFlatMap: r0 a e. <span>(<span class="type-var">'r0</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(Pervasives.result<span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span>, Relude_Void.t)</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'r0</span>, Relude_Void.t)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span>;</code></dt><dt class="spec value" id="val-delay"><a href="#val-delay" class="anchor"></a><code><span class="keyword">let</span> delay: e. int <span>=&gt;</span> <a href="#type-t">t</a><span>(unit, <span class="type-var">'e</span>)</span>;</code></dt><dd><p>Creates an async `IO` that waits for the given millisecond timeout before completing with a unit value.</p></dd></dl><dl><dt class="spec value" id="val-delayWithVoid"><a href="#val-delayWithVoid" class="anchor"></a><code><span class="keyword">let</span> delayWithVoid: int <span>=&gt;</span> <a href="#type-t">t</a><span>(unit, Relude_Void.t)</span>;</code></dt><dd><p>Creates an async non-failing `IO` that waits for the given millisecond timeout before completing with a unit value.</p></dd></dl><dl><dt class="spec value" id="val-withDelayAfter"><a href="#val-withDelayAfter" class="anchor"></a><code><span class="keyword">let</span> withDelayAfter: a e. int <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span>;</code></dt><dd><p>Injects a delay in milliseconds after the given IO. The value or error from the previous IO is propagated after the delay.</p><p>When run, the given IO will be run first, then the delay will be run after the IO finishes.</p><p>Example</p><p>```re IO.pure(4) |&gt; IO.withDelayAfter(2000) |&gt; ... ```</p></dd></dl><dl><dt class="spec value" id="val-withDelay"><a href="#val-withDelay" class="anchor"></a><code><span class="keyword">let</span> withDelay: int <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span>;</code></dt><dd><p>* Alias for withDelayAfter</p></dd></dl><dl><dt class="spec value" id="val-withDelayBefore"><a href="#val-withDelayBefore" class="anchor"></a><code><span class="keyword">let</span> withDelayBefore: a e. int <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span>;</code></dt><dd><p>* Injects a delay before the given IO. * * When run, the delay will be executed first, then the given IO</p></dd></dl><dl><dt class="spec value" id="val-debounce"><a href="#val-debounce" class="anchor"></a><code><span class="keyword">let</span> debounce: r a e. <span>?&#8288;immediate:bool</span> <span>=&gt;</span> <span>?&#8288;intervalMs:int</span> <span>=&gt;</span> <span>(<span class="type-var">'r</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span>)</span> <span>=&gt;</span> <span class="type-var">'r</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(option(<span class="type-var">'a</span>), <span class="type-var">'e</span>)</span>;</code></dt><dd><p>This will &quot;debounce&quot; an IO so that it will only allow the latest call within some interval to go through. All other calls will be cancelled.</p><p>Note: that the IO produced by this function is not referentially transparent, because the IO chain is manipulated at runtime via a mutable ref.</p><p>Example</p><p>```re let ioLog = messageToLog =&gt; IO.pure() |&gt; IO.map(() =&gt; Js.log(messageToLog)); let debouncedIoLog = IO.debounce(ioLog);</p><p>&quot;This message will not get logged&quot; |&gt; debouncedIoLog |&gt; IO.unsafeRunAsync(ignore); &quot;This message will also not get logged&quot; |&gt; debouncedIoLog |&gt; IO.unsafeRunAsync(ignore); &quot;This message will get logged&quot; |&gt; debouncedIoLog |&gt; IO.unsafeRunAsync(ignore); ```</p></dd></dl><dl><dt class="spec value" id="val-throttle"><a href="#val-throttle" class="anchor"></a><code><span class="keyword">let</span> throttle: r a e. <span>?&#8288;intervalMs:int</span> <span>=&gt;</span> <span>(<span class="type-var">'r</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span>)</span> <span>=&gt;</span> <span class="type-var">'r</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(option(<span class="type-var">'a</span>), <span class="type-var">'e</span>)</span>;</code></dt><dd><p>This will &quot;throttle&quot; an IO so that it will only allow subsequent calls to go through after some period of time has elapsed.</p><p>Note: that the IO produced by this function is not referentially transparent, because the IO chain is manipulated at runtime via a mutable ref.</p><p>Example</p><p>```re let ioLog = messageToLog =&gt; IO.pure() |&gt; IO.map(() =&gt; Js.log(messageToLog)); let throttledIoLog = IO.throttled(ioLog);</p><p>&quot;This message will get logged&quot; |&gt; throttledIoLog |&gt; IO.unsafeRunAsync(ignore); &quot;This message will not get logged&quot; |&gt; throttledIoLog |&gt; IO.unsafeRunAsync(ignore); &quot;This message will also not get logged&quot; |&gt; throttledIoLog |&gt; IO.unsafeRunAsync(ignore); ```</p></dd></dl><div class="spec module" id="module-Bifunctor"><a href="#module-Bifunctor" class="anchor"></a><code><span class="keyword">module</span> Bifunctor: BsBastet.Interface.BIFUNCTOR <span class="keyword">with</span> <span class="keyword">type</span> <a href="#module-Bifunctor">Bifunctor</a>.t('a, 'e) = <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span>;</code></div><dl><dt class="spec value" id="val-bimap"><a href="#val-bimap" class="anchor"></a><code><span class="keyword">let</span> bimap: <span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span>)</span> <span>=&gt;</span> <span>(<span class="type-var">'c</span> <span>=&gt;</span> <span class="type-var">'d</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'c</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'b</span>, <span class="type-var">'d</span>)</span>;</code></dt></dl><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> { ... }<span class="keyword">;</span></code></span></summary><dl><dt class="spec value" id="val-mapLeft"><a href="#val-mapLeft" class="anchor"></a><code><span class="keyword">let</span> mapLeft: <span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'c</span>)</span> <span>=&gt;</span> <a href="#module-Bifunctor">Bifunctor</a>.t<span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <span>=&gt;</span> <a href="#module-Bifunctor">Bifunctor</a>.t<span>(<span class="type-var">'c</span>, <span class="type-var">'b</span>)</span>;</code></dt><dt class="spec value" id="val-mapRight"><a href="#val-mapRight" class="anchor"></a><code><span class="keyword">let</span> mapRight: <span>(<span class="type-var">'b</span> <span>=&gt;</span> <span class="type-var">'d</span>)</span> <span>=&gt;</span> <a href="#module-Bifunctor">Bifunctor</a>.t<span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <span>=&gt;</span> <a href="#module-Bifunctor">Bifunctor</a>.t<span>(<span class="type-var">'a</span>, <span class="type-var">'d</span>)</span>;</code></dt><dt class="spec value" id="val-mapError"><a href="#val-mapError" class="anchor"></a><code><span class="keyword">let</span> mapError: <span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span>)</span> <span>=&gt;</span> <a href="#module-Bifunctor">Bifunctor</a>.t<span>(<span class="type-var">'c</span>, <span class="type-var">'a</span>)</span> <span>=&gt;</span> <a href="#module-Bifunctor">Bifunctor</a>.t<span>(<span class="type-var">'c</span>, <span class="type-var">'b</span>)</span>;</code></dt></dl></details></div></div></div><dl><dt class="spec module" id="module-WithError"><a href="#module-WithError" class="anchor"></a><code><span class="keyword">module</span> <a href="WithError">WithError</a>:  (<a href="WithError#argument-1-E">E</a>: BsBastet.Interface.TYPE) <span>=&gt;</span> { ... };</code></dt><dd><p>Because this is a bifunctor, we need to use a module functor to lock in the error type, so we can implement many of the single-type parameter typeclasses.</p></dd></dl></div></body></html>