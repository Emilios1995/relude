<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Relude_Validation (api.Relude_Validation)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../">Up</a> – <a href="../">api</a> &#x00BB; Relude_Validation</nav><h1>Module <code>Relude_Validation</code></h1></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t('a, 'e)</code><code> = </code><table class="variant"><tr id="type-t.VOk" class="anchored"><td class="def constructor"><a href="#type-t.VOk" class="anchor"></a><code>| </code><code><span class="constructor">VOk</span>(<span class="type-var">'a</span>)</code></td></tr><tr id="type-t.VError" class="anchored"><td class="def constructor"><a href="#type-t.VError" class="anchor"></a><code>| </code><code><span class="constructor">VError</span>(<span class="type-var">'e</span>)</code></td></tr></table>;</dt><dd><p>* Similar to result, but has an Applicative instance that collects the errors * using a semigroup, rather than fail-fast semantics.</p></dd></dl><dl><dt class="spec value" id="val-ok"><a href="#val-ok" class="anchor"></a><code><span class="keyword">let</span> ok: a e. <span class="type-var">'a</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span>;</code></dt><dd><p>`ok()` wraps a value in `VOk`</p></dd></dl><dl><dt class="spec value" id="val-error"><a href="#val-error" class="anchor"></a><code><span class="keyword">let</span> error: a e. <span class="type-var">'e</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span>;</code></dt><dd><p>`error(val)` wraps the value in a `VError()`.</p><p>### Example ```re error(&quot;Not even&quot;) == VError(&quot;Not even&quot;); ```</p></dd></dl><dl><dt class="spec value" id="val-errorNel"><a href="#val-errorNel" class="anchor"></a><code><span class="keyword">let</span> errorNel: a e. <span class="type-var">'e</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, Relude_NonEmpty.List.t(<span class="type-var">'e</span>))</span>;</code></dt><dd><p>* Puts an error into a NonEmptyList on the error side of the validation</p></dd></dl><dl><dt class="spec value" id="val-errorNea"><a href="#val-errorNea" class="anchor"></a><code><span class="keyword">let</span> errorNea: a e. <span class="type-var">'e</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, Relude_NonEmpty.Array.t(<span class="type-var">'e</span>))</span>;</code></dt><dd><p>* Puts an error into a NonEmptyArray on the error side of the validation</p></dd></dl><dl><dt class="spec value" id="val-isOk"><a href="#val-isOk" class="anchor"></a><code><span class="keyword">let</span> isOk: a e. <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> bool;</code></dt><dd><p>`isOk(v)` returns `true` if `v` is of the form `VOk(val)`; `false` otherwise.</p></dd></dl><dl><dt class="spec value" id="val-isError"><a href="#val-isError" class="anchor"></a><code><span class="keyword">let</span> isError: a e. <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> bool;</code></dt><dd><p>`isError(x)` returns `true` if `x` is of the form `VError(val)`; `false` otherwise.</p></dd></dl><dl><dt class="spec value" id="val-map"><a href="#val-map" class="anchor"></a><code><span class="keyword">let</span> map: a b e. <span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'b</span>, <span class="type-var">'e</span>)</span>;</code></dt><dd><p>`map(f, x)` returns `VOk(f(x))` if `x` is of the form `VOk(v)`. It returns `VError(e)` if `x` is of the form `VError(e)`.</p><p>### Example ```re map((x) =&gt; <code>sqrt(float_of_int(x))</code>, VOk(4)) == VOk(2.0); map((x) =&gt; <code>sqrt(float_of_int(x))</code>, VError(&quot;bad&quot;)) == VError(&quot;bad&quot;); ```</p></dd></dl><dl><dt class="spec value" id="val-tap"><a href="#val-tap" class="anchor"></a><code><span class="keyword">let</span> tap: a e. <span>(<span class="type-var">'a</span> <span>=&gt;</span> unit)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span>;</code></dt><dd><p>In `tap(f, x)`, function `f()` returns `unit`. Thus, `f()` is used only for its side effects. If `x` is of the form `VOk(v)`, `tap()` calls `f(v)`. The `tap()` function returns the argument `x`.</p><p>### Example ```re tap((x) =&gt; <code>Js.log(x)</code>, VOk(4)) == VOk(4); // prints 4 tap((x) =&gt; <code>Js.log(x)</code>, VError(&quot;bad&quot;)) == VError(&quot;bad&quot;); // prints nothing ```</p></dd></dl><dl><dt class="spec value" id="val-mapError"><a href="#val-mapError" class="anchor"></a><code><span class="keyword">let</span> mapError: a e1 e2. <span>(<span class="type-var">'e1</span> <span>=&gt;</span> <span class="type-var">'e2</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e1</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e2</span>)</span>;</code></dt><dd><p>`mapError(f, x)` returns `VOk(v)` if `x` is of the form `VOk(v)`. It returns `VError(f(e))` if `x` is of the form `VError(e)`.</p><p>### Example ```re mapError((x) =&gt; <code>&quot;Error: &quot; ++ x</code>, VOk(4)) == VOk(4); mapError((x) =&gt; <code>&quot;Error: &quot; ++ x</code>, VError(&quot;bad&quot;)) == VError(&quot;Error: bad&quot;); ```</p></dd></dl><dl><dt class="spec value" id="val-mapErrorsNea"><a href="#val-mapErrorsNea" class="anchor"></a><code><span class="keyword">let</span> mapErrorsNea: a e1 e2. <span>(<span class="type-var">'e1</span> <span>=&gt;</span> <span class="type-var">'e2</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, Relude_NonEmpty.Array.t(<span class="type-var">'e1</span>))</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, Relude_NonEmpty.Array.t(<span class="type-var">'e2</span>))</span>;</code></dt><dd><p>`mapErrorsAsNea()` applies a function to each error in a `NonEmpty.Array` of errors in the error channel of the `Validation`.</p></dd></dl><dl><dt class="spec value" id="val-mapErrorsNel"><a href="#val-mapErrorsNel" class="anchor"></a><code><span class="keyword">let</span> mapErrorsNel: a e1 e2. <span>(<span class="type-var">'e1</span> <span>=&gt;</span> <span class="type-var">'e2</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, Relude_NonEmpty.List.t(<span class="type-var">'e1</span>))</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, Relude_NonEmpty.List.t(<span class="type-var">'e2</span>))</span>;</code></dt><dd><p>`mapErrorsAsNel()` applies a function to each error in a `NonEmpty.List` of errors in the error channel of the `Validation`.</p></dd></dl><dl><dt class="spec value" id="val-tapError"><a href="#val-tapError" class="anchor"></a><code><span class="keyword">let</span> tapError: a e. <span>(<span class="type-var">'e</span> <span>=&gt;</span> unit)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span>;</code></dt><dd><p>In `tapError(f, x)`, function `f()` returns `unit`. Thus, `f()` is used only for its side effects. If `x` is of the form `VError(v)`, `tap()` calls `f(v)`. The `tap()` function returns the argument `x`.</p><p>### Example ```re tapError((x) =&gt; <code>Js.log(x)</code>, VOk(4)) == VOk(4); // prints nothing tapError((x) =&gt; <code>Js.log(x)</code>, VError(&quot;bad&quot;)) == VError(&quot;bad&quot;); // prints &quot;bad&quot; ```</p></dd></dl><dl><dt class="spec value" id="val-bimap"><a href="#val-bimap" class="anchor"></a><code><span class="keyword">let</span> bimap: a b e1 e2. <span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span>)</span> <span>=&gt;</span> <span>(<span class="type-var">'e1</span> <span>=&gt;</span> <span class="type-var">'e2</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e1</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'b</span>, <span class="type-var">'e2</span>)</span>;</code></dt><dd><p>`bimap(f, g, x)` returns `VOk(f(v))` if `x` is of the form `VOk(v)`; it returns `VError(g(e))` if `x` is of the form `VError(e)`.</p><p>### Example ```re let cube = (x) =&gt; <code>x * x * x</code>; let label = (x) =&gt; <code>&quot;Error: &quot; ++ x</code>; bimap(cube, label, VOk(12)) == VOk(1728); bimap(cube, label, VError(&quot;bad&quot;)) == VError(&quot;Error: bad&quot;); ```</p></dd></dl><dl><dt class="spec value" id="val-bitap"><a href="#val-bitap" class="anchor"></a><code><span class="keyword">let</span> bitap: a e. <span>(<span class="type-var">'a</span> <span>=&gt;</span> unit)</span> <span>=&gt;</span> <span>(<span class="type-var">'e</span> <span>=&gt;</span> unit)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span>;</code></dt><dd><p>`bitap(f, g, x)` the functions `f()` and `g()` both return `unit`, so they are used only for their side effects. If `x` is of the form `VOk(v)`, `bitap()` calls `f(v)`; if `x is of the form `VError(e), `bitap()` calls `g(e)`. In either case, `bitap()` returns `x`.</p><p>### Example ```re let printCube = (x) =&gt; <code>Js.log(x * x * x)</code>; let printLabel = (x) =&gt; <code>Js.log(&quot;Error: &quot; ++ x)</code>; bitap(printCube, printLabel, VOk(12)) == VOk(12); // prints 1728 bitap(printCube, printLabel, VError(&quot;bad&quot;)) == VError(&quot;bad&quot;); // prints &quot;Error: bad&quot; ```</p></dd></dl><dl><dt class="spec value" id="val-applyWithAppendErrors"><a href="#val-applyWithAppendErrors" class="anchor"></a><code><span class="keyword">let</span> applyWithAppendErrors: a b e. <span>(<span class="type-var">'e</span> <span>=&gt;</span> <span class="type-var">'e</span> <span>=&gt;</span> <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'b</span>, <span class="type-var">'e</span>)</span>;</code></dt><dd><p>`apply(valFcn, x, appErrFcn)` provides a way of creating a chain of validation functions, accumulating errors along the way.</p><p>If `valFcn` is of the form `VOk(f)`, function `f` is applied to `x`. If `x` is `VOk(v)`, the result is `VOk(f(v))`. If `x` is `VError(err)`, the error is passed onwards.</p><p>If `valFcn` is itself of the form `VError(err)` and `x` is `VOk(v)`, `VError(err)` is passed on.</p><p>Finally, if both `valFcn` and `x` are `VError(e1)` and `VError(e2)`, the result is `VError(appendErrFcn(e1, e2))`.</p><p>Using `apply()` properly is somewhat complex. See the example in the `__tests__/Relude_Validation_test.re` file for more details.</p></dd></dl><dl><dt class="spec value" id="val-alignWithAppendErrors"><a href="#val-alignWithAppendErrors" class="anchor"></a><code><span class="keyword">let</span> alignWithAppendErrors: a b e. <span>(<span class="type-var">'e</span> <span>=&gt;</span> <span class="type-var">'e</span> <span>=&gt;</span> <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'b</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(Relude_Ior_Type.t<span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span>, <span class="type-var">'e</span>)</span>;</code></dt><dt class="spec value" id="val-alignWithWithAppendErrors"><a href="#val-alignWithWithAppendErrors" class="anchor"></a><code><span class="keyword">let</span> alignWithWithAppendErrors: a b c e. <span>(<span class="type-var">'e</span> <span>=&gt;</span> <span class="type-var">'e</span> <span>=&gt;</span> <span class="type-var">'e</span>)</span> <span>=&gt;</span> <span>(Relude_Ior_Type.t<span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <span>=&gt;</span> <span class="type-var">'c</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'b</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'c</span>, <span class="type-var">'e</span>)</span>;</code></dt><dt class="spec value" id="val-pure"><a href="#val-pure" class="anchor"></a><code><span class="keyword">let</span> pure: a e. <span class="type-var">'a</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span>;</code></dt><dd><p>`pure(val)` wraps its argument in a `VOk()`.</p><p>### Example ```re pure(3) == VOk(3); ```</p></dd></dl><dl><dt class="spec value" id="val-bind"><a href="#val-bind" class="anchor"></a><code><span class="keyword">let</span> bind: a b e. <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <span>(<span class="type-var">'a</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'b</span>, <span class="type-var">'e</span>)</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'b</span>, <span class="type-var">'e</span>)</span>;</code></dt><dd><p>`flatMapV(x, f)` returns `f(v)` when `x` is of the form `VOk(v)`, and returns `x` unchanged when it is of the form `VError(v)`.</p><p>Note: `Validation` is not a traditional monad in that it's purpose is to collect errors during applicative validation. Using `flatMap` will cause all previous errors to be discarded.</p><p>### Example ```re let mustBeEven = (x) =&gt; <code>
    (x mod 2 == 0) ? VOk(x) : VError(&quot;not even&quot;)
  </code>; flatMapV(VOk(12), mustBeEven) == VOk(12); flatMapV(VOk(3), mustBeEven) == VError(&quot;not even&quot;); flatMapV(VError(&quot;not an int&quot;), mustBeEven) == VError(&quot;not an int&quot;); ```</p></dd></dl><dl><dt class="spec value" id="val-flatMap"><a href="#val-flatMap" class="anchor"></a><code><span class="keyword">let</span> flatMap: a b e. <span>(<span class="type-var">'a</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'b</span>, <span class="type-var">'e</span>)</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'b</span>, <span class="type-var">'e</span>)</span>;</code></dt><dd><p>* `bind` is the same as `flatMap` with the arguments flipped.</p></dd></dl><dl><dt class="spec value" id="val-fromResult"><a href="#val-fromResult" class="anchor"></a><code><span class="keyword">let</span> fromResult: Pervasives.result<span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span>;</code></dt><dd><p>* `fromResult` converts a value of type `result` to a `Validation.t`, returning * `VOk(x)` if the result was `Ok(x)` and `VError(x)` if the result was * `Error(x)`.</p></dd></dl><dl><dt class="spec value" id="val-toResult"><a href="#val-toResult" class="anchor"></a><code><span class="keyword">let</span> toResult: <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <span>=&gt;</span> Pervasives.result<span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span>;</code></dt><dd><p>* `toResult` converts a value of type `Validation.t` to `result`.</p></dd></dl><dl><dt class="spec value" id="val-fromOption"><a href="#val-fromOption" class="anchor"></a><code><span class="keyword">let</span> fromOption: a e. <span class="type-var">'e</span> <span>=&gt;</span> option(<span class="type-var">'a</span>) <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span>;</code></dt><dd><p>* `fromOption` converts an `option` into a `Validation.t`, returning `VOk(x)` * if the option was `Some(x)` and `VError` (constructed with the provided * error) if the option was `None`.</p></dd></dl><dl><dt class="spec value" id="val-fromOptionLazy"><a href="#val-fromOptionLazy" class="anchor"></a><code><span class="keyword">let</span> fromOptionLazy: a e. <span>(unit <span>=&gt;</span> <span class="type-var">'e</span>)</span> <span>=&gt;</span> option(<span class="type-var">'a</span>) <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span>;</code></dt><dd><p>* `fromOptionLazy` converts an `option` into a `Validation.t`, similar to * `fromOption`, except that provided error is constructed lazily by calling a * function. This is useful if the error is expensive to construct, especially * since it may not be needed.</p></dd></dl><dl><dt class="spec value" id="val-fold"><a href="#val-fold" class="anchor"></a><code><span class="keyword">let</span> fold: a e c. <span>(<span class="type-var">'e</span> <span>=&gt;</span> <span class="type-var">'c</span>)</span> <span>=&gt;</span> <span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'c</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <span class="type-var">'c</span>;</code></dt><dd><p>* `fold(errFn, okFn, x)` returns `okFn(v)` when the provided Validation (`x`) * is `VOk(v)`; it returns `errFn(e)` when the Validation is `VError(e)`. This * is effectively a function that allows you to &quot;handle&quot; both possible states of * the Validation. * * ```re * let positiveInt = str =&gt; * Validate.( * Int.fromtString(str) * |&gt; fromOption(`InvalidInput) * |&gt; flatMapV(x =&gt; x &lt; 0 ? error(`NotPositive) : pure(x)) * ); * * let showError = * fun * | `InvalidInput =&gt; &quot;The provided string was not an int&quot; * | `NotPositive =&gt; &quot;The provided int was negative&quot;; * * * let errMsg = x =&gt; &quot;Something went wrong: &quot; ++ showError(x); * let succMsg = x =&gt; &quot;Found valid positive int: &quot; ++ Int.toString(x); * * // &quot;Something went wrong: The provided string was not an int&quot; * fold(errMsg, succMsg, positiveInt(&quot;a&quot;)); * * // &quot;Something went wrong: The provided int was negative&quot; * fold(errMsg, succMsg, positiveInt(&quot;-3&quot;)); * * // &quot;Found valid positive int: 123&quot; * fold(errMsg, succMsg, positiveInt(&quot;123&quot;)); * ```</p></dd></dl><dl><dt class="spec value" id="val-flip"><a href="#val-flip" class="anchor"></a><code><span class="keyword">let</span> flip: a e. <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'e</span>, <span class="type-var">'a</span>)</span>;</code></dt><dd><p>* `flip` Flips the values between the success and error channels. * * ```re * flip(VOk(12)) == VError(12); * flip(VError(-1)) == VOk(-1); * ```</p></dd></dl><dl><dt class="spec value" id="val-map2"><a href="#val-map2" class="anchor"></a><code><span class="keyword">let</span> map2: <span>(<span class="type-var">'x</span> <span>=&gt;</span> <span class="type-var">'x</span> <span>=&gt;</span> <span class="type-var">'x</span>)</span> <span>=&gt;</span> <span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span> <span>=&gt;</span> <span class="type-var">'c</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'x</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'b</span>, <span class="type-var">'x</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'c</span>, <span class="type-var">'x</span>)</span>;</code></dt><dt class="spec value" id="val-map3"><a href="#val-map3" class="anchor"></a><code><span class="keyword">let</span> map3: <span>(<span class="type-var">'x</span> <span>=&gt;</span> <span class="type-var">'x</span> <span>=&gt;</span> <span class="type-var">'x</span>)</span> <span>=&gt;</span> <span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span> <span>=&gt;</span> <span class="type-var">'c</span> <span>=&gt;</span> <span class="type-var">'d</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'x</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'b</span>, <span class="type-var">'x</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'c</span>, <span class="type-var">'x</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'d</span>, <span class="type-var">'x</span>)</span>;</code></dt><dt class="spec value" id="val-map4"><a href="#val-map4" class="anchor"></a><code><span class="keyword">let</span> map4: <span>(<span class="type-var">'x</span> <span>=&gt;</span> <span class="type-var">'x</span> <span>=&gt;</span> <span class="type-var">'x</span>)</span> <span>=&gt;</span> <span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span> <span>=&gt;</span> <span class="type-var">'c</span> <span>=&gt;</span> <span class="type-var">'d</span> <span>=&gt;</span> <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'x</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'b</span>, <span class="type-var">'x</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'c</span>, <span class="type-var">'x</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'d</span>, <span class="type-var">'x</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'e</span>, <span class="type-var">'x</span>)</span>;</code></dt><dt class="spec value" id="val-map5"><a href="#val-map5" class="anchor"></a><code><span class="keyword">let</span> map5: <span>(<span class="type-var">'x</span> <span>=&gt;</span> <span class="type-var">'x</span> <span>=&gt;</span> <span class="type-var">'x</span>)</span> <span>=&gt;</span> <span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span> <span>=&gt;</span> <span class="type-var">'c</span> <span>=&gt;</span> <span class="type-var">'d</span> <span>=&gt;</span> <span class="type-var">'e</span> <span>=&gt;</span> <span class="type-var">'f</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'x</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'b</span>, <span class="type-var">'x</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'c</span>, <span class="type-var">'x</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'d</span>, <span class="type-var">'x</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'e</span>, <span class="type-var">'x</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'f</span>, <span class="type-var">'x</span>)</span>;</code></dt></dl><div class="spec module" id="module-WithErrors"><a href="#module-WithErrors" class="anchor"></a><code><span class="keyword">module</span> <a href="WithErrors">WithErrors</a>:  (<a href="WithErrors#argument-1-Errors">Errors</a>: BsBastet.Interface.SEMIGROUP_ANY) <span>=&gt;</span>  (<a href="WithErrors#argument-2-Error">Error</a>: BsBastet.Interface.TYPE) <span>=&gt;</span> { ... };</code></div></div></body></html>