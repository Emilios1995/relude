<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Relude_Result (api.Relude_Result)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../">Up</a> – <a href="../">api</a> &#x00BB; Relude_Result</nav><h1>Module <code>Relude_Result</code></h1></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t('a, 'e)</code><code> = Pervasives.result<span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span></code><code> = </code><table class="variant"><tr id="type-t.Ok" class="anchored"><td class="def constructor"><a href="#type-t.Ok" class="anchor"></a><code>| </code><code><span class="constructor">Ok</span>(<span class="type-var">'a</span>)</code></td></tr><tr id="type-t.Error" class="anchored"><td class="def constructor"><a href="#type-t.Error" class="anchor"></a><code>| </code><code><span class="constructor">Error</span>(<span class="type-var">'e</span>)</code></td></tr></table>;</dt></dl><dl><dt class="spec value" id="val-ok"><a href="#val-ok" class="anchor"></a><code><span class="keyword">let</span> ok: a e. <span class="type-var">'a</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span>;</code></dt><dd><p>`ok()` is a synonym for `pure()`.</p></dd></dl><dl><dt class="spec value" id="val-error"><a href="#val-error" class="anchor"></a><code><span class="keyword">let</span> error: a e. <span class="type-var">'e</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span>;</code></dt><dd><p>`error(x)` wraps its argument in `Error()`.</p><pre><code class="ml">error(&quot;Not even&quot;) == Error(&quot;Not even&quot;);</code></pre></dd></dl><dl><dt class="spec value" id="val-unit"><a href="#val-unit" class="anchor"></a><code><span class="keyword">let</span> unit: e. <a href="#type-t">t</a><span>(unit, <span class="type-var">'e</span>)</span>;</code></dt><dd><p><code>Result.unit</code> is an <code>Ok</code> value that holds <code>()</code>.</p><pre><code class="ml">Result.unit == Ok();</code></pre></dd></dl><dl><dt class="spec value" id="val-getOk"><a href="#val-getOk" class="anchor"></a><code><span class="keyword">let</span> getOk: a e. <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> option(<span class="type-var">'a</span>);</code></dt><dd><p>`getOk(result)` returns `Some(v)` when `result` is of the form `Ok(v)`; otherwise it returns `None`.</p><pre><code class="ml">getOk(Ok(1066)) == Some(1066);
getOk(Error(&quot;bad value&quot;)) == None;</code></pre></dd></dl><dl><dt class="spec value" id="val-toOption"><a href="#val-toOption" class="anchor"></a><code><span class="keyword">let</span> toOption: a e. <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> option(<span class="type-var">'a</span>);</code></dt><dd><p>Alias for `getOk`</p></dd></dl><dl><dt class="spec value" id="val-getError"><a href="#val-getError" class="anchor"></a><code><span class="keyword">let</span> getError: a e. <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> option(<span class="type-var">'e</span>);</code></dt><dd><p>`getError(result)` returns `Some(e)` when `result` is of the form `Error(e)`; otherwise it returns `None`.</p><pre><code class="ml">getError(Ok(1066)) == None;
getError(Error(&quot;bad value&quot;)) == Some(&quot;bad value&quot;);</code></pre></dd></dl><dl><dt class="spec value" id="val-isOk"><a href="#val-isOk" class="anchor"></a><code><span class="keyword">let</span> isOk: a e. <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> bool;</code></dt><dd><p>`isOK(result)` returns `true` if `result` is of the form `Ok(val)`, `false` otherwise.</p></dd></dl><dl><dt class="spec value" id="val-isError"><a href="#val-isError" class="anchor"></a><code><span class="keyword">let</span> isError: a e. <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> bool;</code></dt><dd><p>`isError(result)` returns `true` if `result` is of the form `Error(err)`, `false` otherwise.</p></dd></dl><dl><dt class="spec value" id="val-fold"><a href="#val-fold" class="anchor"></a><code><span class="keyword">let</span> fold: a e c. <span>(<span class="type-var">'e</span> <span>=&gt;</span> <span class="type-var">'c</span>)</span> <span>=&gt;</span> <span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'c</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <span class="type-var">'c</span>;</code></dt><dd><p>`fold(errFcn, okFcn, x)` returns `okFcn(v)` when `x` is of the form `Ok(v)`; it returns `errFcn(e)` when `x` is of the form `Error(e)`.</p><pre><code class="ml">let errToInt = (_) =&gt; {-1};
let cube = (x) =&gt; {x * x * x};
fold(errToInt, cube, Ok(12)) == 1728;
fold(errToInt, cube, Error(&quot;bad&quot;)) == -1;</code></pre></dd></dl><dl><dt class="spec value" id="val-getOrElse"><a href="#val-getOrElse" class="anchor"></a><code><span class="keyword">let</span> getOrElse: a e. <span class="type-var">'a</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <span class="type-var">'a</span>;</code></dt><dd><p>`getOrElse(default, result)` returns `v` when `result` is of the form `Ok(v)`; otherwise, it returns `default`.</p><pre><code class="ml">let safeAvg = (total, n): Relude.Result.t(float, string) =&gt; {
  if (n &gt; 0) {
    Ok(total /. float_of_int(n));
  } else {
    Error(&quot;Cannot calcuate average&quot;);
  };
};

getOrElse(0.0, safeAvg(32.0, 4)) == 8.0;
getOrElse(0.0, safeAvg(0.0, 0)) == 0.0;</code></pre></dd></dl><dl><dt class="spec value" id="val-getOrElseLazy"><a href="#val-getOrElseLazy" class="anchor"></a><code><span class="keyword">let</span> getOrElseLazy: a e. <span>(unit <span>=&gt;</span> <span class="type-var">'a</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <span class="type-var">'a</span>;</code></dt><dd><p>`getOrElseLazy` returns the `Ok` value inside the `result` or calls the provided function to get a value if the result is `Error`. Unlike `getOrElse`, this only constructs the fallback value if it's needed, which may be useful if the fallback is expensive to construct.</p></dd></dl><dl><dt class="spec value" id="val-merge"><a href="#val-merge" class="anchor"></a><code><span class="keyword">let</span> merge: a. <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'a</span>)</span> <span>=&gt;</span> <span class="type-var">'a</span>;</code></dt><dd><p>`merge(x)` “unwraps” its argument. If `x` is of the form `Ok(v)`, the result is `v`. If `x` is of the form Error(e), the result is `e`.</p><pre><code class="ml">merge(Ok(2)) == 2;
merge(Error(&quot;message&quot;)) == &quot;message&quot;;</code></pre></dd></dl><dl><dt class="spec value" id="val-flip"><a href="#val-flip" class="anchor"></a><code><span class="keyword">let</span> flip: a e. <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'e</span>, <span class="type-var">'a</span>)</span>;</code></dt><dd><p>`flip(x)` flips the values between the `Ok` and `Error` constructors. `Ok(val)`.</p><pre><code class="ml">flip(Ok(3)) == Error(3);
flip(Error(-1)) == Ok(-1);</code></pre></dd></dl><dl><dt class="spec value" id="val-compose"><a href="#val-compose" class="anchor"></a><code><span class="keyword">let</span> compose: a b c e. <a href="#type-t">t</a><span>(<span class="type-var">'b</span> <span>=&gt;</span> <span class="type-var">'c</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'c</span>, <span class="type-var">'e</span>)</span>;</code></dt><dt class="spec value" id="val-andThen"><a href="#val-andThen" class="anchor"></a><code><span class="keyword">let</span> andThen: a b c e. <a href="#type-t">t</a><span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'b</span> <span>=&gt;</span> <span class="type-var">'c</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'c</span>, <span class="type-var">'e</span>)</span>;</code></dt><dt class="spec value" id="val-map"><a href="#val-map" class="anchor"></a><code><span class="keyword">let</span> map: a b e. <span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'b</span>, <span class="type-var">'e</span>)</span>;</code></dt><dd><p>`map(f, x)` returns `Ok(f(x))` if `x` is of the form `OK(v)`. It returns `Error(e)` if `x` is of the form `Error(e)`.</p><pre><code class="ml">map(x =&gt; sqrt(float_of_int(x)), Ok(4)) == Ok(2.0);
map(x =&gt; sqrt(float_of_int(x)), Error(&quot;bad&quot;)) == Error(&quot;bad&quot;);</code></pre><p>One place you might use `map()` is in validating input to an “ordinary” function. Consider the (highly artificial) example where you have a function that will cube a number, but you only want to do so if the number is even. Here are the functions:</p><pre><code class="ml">type intResult = Relude.Result.t(int, string);
let cube = (x) =&gt; {x * x * x};
let testEven = (n): intResult =&gt; {
  (n mod 2 == 0) ? Ok(n) :
    Error(string_of_int(n) ++ &quot; is not even.&quot;)
};</code></pre><p>We can now make calls like this:</p><pre><code class="ml">map(cube, testEven(12)) == Ok(1728);
map(cube, testEven(5)) == Error(&quot;5 is not even.&quot;);</code></pre><p>This is something we could have done with a simple `if` statement, but we will see `map()` become useful when we have several things to validate. (See `apply()` and `map2()`, `map3()`, etc.)</p></dd></dl><dl><dt class="spec value" id="val-mapOk"><a href="#val-mapOk" class="anchor"></a><code><span class="keyword">let</span> mapOk: <span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'c</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'b</span>, <span class="type-var">'c</span>)</span>;</code></dt><dd><p>`mapOk` is a synonym for `map`</p></dd></dl><dl><dt class="spec value" id="val-mapError"><a href="#val-mapError" class="anchor"></a><code><span class="keyword">let</span> mapError: a e1 e2. <span>(<span class="type-var">'e1</span> <span>=&gt;</span> <span class="type-var">'e2</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e1</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e2</span>)</span>;</code></dt><dd><p>`mapError(f, x)` returns `Ok(v)` if `x` is of the form `OK(v)`. It returns `Error(f(e))` if `x` is of the form `Error(e)`.</p><pre><code class="ml">mapError((x) =&gt; {&quot;Err: &quot; ++ x}, Ok(4)) == Ok(4);
mapError((x) =&gt; {&quot;Err: &quot; ++ x}, Error(&quot;bad&quot;)) == Error(&quot;Err: bad&quot;);</code></pre></dd></dl><dl><dt class="spec value" id="val-bimap"><a href="#val-bimap" class="anchor"></a><code><span class="keyword">let</span> bimap: a b e1 e2. <span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span>)</span> <span>=&gt;</span> <span>(<span class="type-var">'e1</span> <span>=&gt;</span> <span class="type-var">'e2</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e1</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'b</span>, <span class="type-var">'e2</span>)</span>;</code></dt><dd><p>`bimap(f, g, x)` returns `Ok(f(v))` if `x` is of the form `Ok(v)`; it returns `Error(g(e))` if `x` is of the form `Error(e)`.</p><pre><code class="ml">let cube = x =&gt; x * x * x;
let label = x =&gt; &quot;Err: &quot; ++ x;

bimap(cube, label, Ok(12)) == Ok(1728);
bimap(cube, label, Error(&quot;bad&quot;)) == Error(&quot;Err: bad&quot;);</code></pre></dd></dl><dl><dt class="spec value" id="val-tap"><a href="#val-tap" class="anchor"></a><code><span class="keyword">let</span> tap: a e. <span>(<span class="type-var">'a</span> <span>=&gt;</span> unit)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span>;</code></dt><dd><p>In `tap(f, x)`, function `f()` returns `unit`. Thus, `f()` is used only for its side effects. If `x` is of the form `Ok(v)`, `tap()` calls `f(v)`. The `tap()` function returns the argument `x`.</p><pre><code class="ml">tap(x =&gt; Js.log(x), Ok(4)) == Ok(4); // prints 4
tap(x =&gt; Js.log(x), Error(&quot;bad&quot;)) == Error(&quot;bad&quot;); // prints nothing</code></pre></dd></dl><dl><dt class="spec value" id="val-tapOk"><a href="#val-tapOk" class="anchor"></a><code><span class="keyword">let</span> tapOk: a e. <span>(<span class="type-var">'a</span> <span>=&gt;</span> unit)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span>;</code></dt><dd><p>`tapOk` is a synonym for `tap`.</p></dd></dl><dl><dt class="spec value" id="val-tapError"><a href="#val-tapError" class="anchor"></a><code><span class="keyword">let</span> tapError: a e. <span>(<span class="type-var">'e</span> <span>=&gt;</span> unit)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span>;</code></dt><dd><p>In `tapError(f, x)`, function `f()` returns `unit`. Thus, `f()` is used only for its side effects. If `x` is of the form `Error(v)`, `tap()` calls `f(v)`. The `tap()` function returns the argument `x`.</p><pre><code class="ml">tapError(x =&gt; Js.log(x), Ok(4)) == Ok(4); // prints nothing
tapError(x =&gt; Js.log(x), Error(&quot;bad&quot;)) == Error(&quot;bad&quot;); // prints &quot;bad&quot;</code></pre></dd></dl><dl><dt class="spec value" id="val-apply"><a href="#val-apply" class="anchor"></a><code><span class="keyword">let</span> apply: a b e. <a href="#type-t">t</a><span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'b</span>, <span class="type-var">'e</span>)</span>;</code></dt><dd><p>`apply(fcn, x)` provides a way of creating a chain of validation functions.</p><p>If `fcn` is of the form `Ok(f)`, function `f` is applied to `x`. If `x` is `Ok(v)`, the result is `Ok(f(v))`. If `x` is `Error(err)`, the error is passed onwards.</p><p>If `fcn` is itself of the form `Error(err)` and `x` is `Ok(v)`, `Error(err)` is passed on.</p><p>Finally, if both `fcn` and `x` are `Error(e1)` and `Error(e2)`, the result is `Error(e2)`.</p><p>Using `apply()` properly is somewhat complex. See the example in the `__tests__/Relude_Validation_test.re` file for more details. (It uses `VOk` and `VError`, but the logic is identical.)</p></dd></dl><dl><dt class="spec value" id="val-map2"><a href="#val-map2" class="anchor"></a><code><span class="keyword">let</span> map2: a b c x. <span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span> <span>=&gt;</span> <span class="type-var">'c</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'x</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'b</span>, <span class="type-var">'x</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'c</span>, <span class="type-var">'x</span>)</span>;</code></dt><dd><p>`map2(f, x, y)` has as its first argument a function that takes two values. If both of `x` and `y` are of the form `Ok(xv)` and `Ok(yv)`, `map2()` returns `Ok(f(xv, yv))`. Otherwise, it returns the last value of type `Error(e)` that it encounters.</p><p>Here is another artificial example that concatenates a string and integer, but only if the string is non-empty and the number is odd:</p><pre><code class="ml">let combine = (str, n) =&gt; {str ++ &quot; &quot; ++ string_of_int(n)};

type strResult = Relude.Result.t(string, string);
let testStr = (s): strResult =&gt; (s == &quot;&quot;) ? Error(&quot;empty string&quot;): Ok(s);
let testOdd = (n): intResult =&gt; (n mod 2 == 0) ? Error(&quot;not odd&quot;) : Ok(n);

map2(combine, testStr(&quot;cloud&quot;), testOdd(9)) == Ok(&quot;cloud 9&quot;);
map2(combine, testStr(&quot;cloud&quot;), testOdd(10)) == Error(&quot;not odd&quot;);
map2(combine, testStr(&quot;&quot;), testOdd(9)) == Error(&quot;empty string&quot;);
map2(combine, testStr(&quot;&quot;), testOdd(10)) == Error(&quot;not odd&quot;);</code></pre></dd></dl><dl><dt class="spec value" id="val-map3"><a href="#val-map3" class="anchor"></a><code><span class="keyword">let</span> map3: a b c d x. <span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span> <span>=&gt;</span> <span class="type-var">'c</span> <span>=&gt;</span> <span class="type-var">'d</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'x</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'b</span>, <span class="type-var">'x</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'c</span>, <span class="type-var">'x</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'d</span>, <span class="type-var">'x</span>)</span>;</code></dt><dd><p>`map3(f, x, y, z)` has as its first argument a function that takes three values. If all of `x`, `y`, and `z` are of the form `Ok(xv)`, `Ok(yv)`, and `Ok(zv)`, `map3()` returns `Ok(f(xv, yv, zv))`. Otherwise, it returns the last value of type `Error(e)` that it encounters.</p><p>The following example builds on the example from `map2()` and does not show all the possible combinations.</p><pre><code class="ml">let combine = (str, n1, n2) =&gt; {str ++ &quot; &quot; ++ string_of_int(n1 * n2)};
let testLimit = (n): intResult =&gt; {(n &lt; 100) ? Ok(n) : Error(&quot;too big&quot;)};

map3(combine, testStr(&quot;cloud&quot;), testOdd(3), testLimit(3)) == Ok(&quot;cloud 9&quot;);
map3(combine, testStr(&quot;cloud&quot;), testOdd(2), testLimit(3)) == Error(&quot;not odd&quot;);
map3(combine, testStr(&quot;&quot;), testOdd(3), testLimit(3)) == Error(&quot;empty string&quot;);
map3(combine, testStr(&quot;&quot;), testOdd(10), testLimit(100)) == Error(&quot;too big&quot;);</code></pre></dd></dl><dl><dt class="spec value" id="val-map4"><a href="#val-map4" class="anchor"></a><code><span class="keyword">let</span> map4: a b c d e x. <span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span> <span>=&gt;</span> <span class="type-var">'c</span> <span>=&gt;</span> <span class="type-var">'d</span> <span>=&gt;</span> <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'x</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'b</span>, <span class="type-var">'x</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'c</span>, <span class="type-var">'x</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'d</span>, <span class="type-var">'x</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'e</span>, <span class="type-var">'x</span>)</span>;</code></dt><dd><p>`map4(f, x, y, z, w)` has as its first argument a function that takes four values. If all of `x`, `y`, `z`, and `w` are of the form `Ok(xv)`, `Ok(yv)`, `Ok(zv)`, and `Ok(wv)`, `map4()` returns `Ok(f(xv, yv, zv, wv))`. Otherwise, it returns the last value of type `Error(e)` that it encounters.</p><p>This example uses validation functions defined in the example from `map3()`.</p><pre><code class="ml">let combine = (s1, n2, n3, n4) =&gt; {s1 ++ &quot; &quot; ++ string_of_int(n2 + n3 + n4)};
let testPositive = (n): intResult =&gt; {(n &gt; 0) ? Ok(n) : Error(&quot;not positive&quot;)};
map4(combine, testStr(&quot;car&quot;), testOdd(49), testPositive(2), testLimit(3)) == Ok(&quot;car 54&quot;);
map4(combine, testStr(&quot;car&quot;), testOdd(50), testPositive(2), testLimit(200)) == Error(&quot;too big&quot;);
map4(combine, testStr(&quot;&quot;), testOdd(49), testPositive(-5), testLimit(0)) == Error(&quot;not positive&quot;);
map4(combine, testStr(&quot;&quot;), testOdd(48), testPositive(-9), testLimit(200))
  == Error(&quot;too big&quot;); // all failures</code></pre></dd></dl><dl><dt class="spec value" id="val-map5"><a href="#val-map5" class="anchor"></a><code><span class="keyword">let</span> map5: a b c d e f x. <span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span> <span>=&gt;</span> <span class="type-var">'c</span> <span>=&gt;</span> <span class="type-var">'d</span> <span>=&gt;</span> <span class="type-var">'e</span> <span>=&gt;</span> <span class="type-var">'f</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'x</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'b</span>, <span class="type-var">'x</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'c</span>, <span class="type-var">'x</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'d</span>, <span class="type-var">'x</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'e</span>, <span class="type-var">'x</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'f</span>, <span class="type-var">'x</span>)</span>;</code></dt><dd><p>`map5(f, x, y, z, w, q)` has as its first argument a function that takes five values. If all of `x`, `y`, `z`, `w`, and `q` are of the form `Ok(xv)`, `Ok(yv)`, `Ok(zv)`, `Ok(wv)`, and `Ok(qv)`, `map5()` returns `Ok(f(xv, yv, zv, wv, qv))`. Otherwise, it returns the last value of type `Error(e)` that it encounters.</p><p>The following examples do not show all the possible combinations.</p><pre><code class="ml">let combine = (s1, n2, n3, n4, n5) =&gt; {s1 ++ &quot; &quot; ++ string_of_int(n2 + n3 + n4 + n5)};
let testNegative = (n): intResult =&gt; {(n &lt; 0) ? Ok(n) : Error(&quot;not negative&quot;)};

map5(combine, testStr(&quot;square&quot;), testOdd(5), testPositive(2),
  testLimit(3), testNegative(-9)) == Ok(&quot;square 1&quot;);
map5(combine, testStr(&quot;square&quot;), testOdd(2), testPositive(5), testLimit(200),
  testNegative(-3)) == Error(&quot;too big&quot;);
map5(combine, testStr(&quot;&quot;), testOdd(3), testPositive(5), testLimit(7),
  testNegative(-9)) == Error(&quot;empty string&quot;);
map5(combine, testStr(&quot;&quot;), testOdd(2), testPositive(-2), testLimit(200),
  testNegative(42)) == Error(&quot;not negative&quot;); // all failures</code></pre></dd></dl><dl><dt class="spec value" id="val-pure"><a href="#val-pure" class="anchor"></a><code><span class="keyword">let</span> pure: a e. <span class="type-var">'a</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span>;</code></dt><dd><p>`pure(x)` wraps its argument in `Ok()`.</p><pre><code class="ml">pure(3) == Ok(3);</code></pre></dd></dl><dl><dt class="spec value" id="val-bind"><a href="#val-bind" class="anchor"></a><code><span class="keyword">let</span> bind: a b e. <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <span>(<span class="type-var">'a</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'b</span>, <span class="type-var">'e</span>)</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'b</span>, <span class="type-var">'e</span>)</span>;</code></dt><dd><p>In `bind(r, f)`, `f()` is a function that takes a non-`Result` argument and returns a `Result` value. If `r` is of the form `Ok(val)`, then `bind()` returns `f(val)`. Otherwise, it returns `r`, which will be an `Error(err)`.</p><p>Note: `bind()` is the same as `flatMap()`, except with the arguments in reverse order.</p><pre><code class="ml">let safeSqrt = (x): Relude.Result.t(float, string) =&gt; {
  (x &gt;= 0.0) ? Ok(sqrt(x)) : Error(&quot;cannot be negative&quot;)
};
bind(Ok(4.0), safeSqrt) == Ok(2.0);
bind(Error(&quot;invalid float&quot;), safeSqrt) == Error(&quot;invalid float&quot;);</code></pre></dd></dl><dl><dt class="spec value" id="val-flatMap"><a href="#val-flatMap" class="anchor"></a><code><span class="keyword">let</span> flatMap: a b e. <span>(<span class="type-var">'a</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'b</span>, <span class="type-var">'e</span>)</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'b</span>, <span class="type-var">'e</span>)</span>;</code></dt><dd><p>In `flatMap(f, r)`, `f()` is a function that takes a non-`Result` argument and returns a `Result` value. If `r` is of the form `Ok(val)`, then `flatMap()` returns `f(val)`. Otherwise, it returns `r`, which will be an `Error(err)`.</p><pre><code class="ml">let safeSqrt = x =&gt;
  (x &gt;= 0.0) ? Ok(sqrt(x)) : Error(&quot;cannot be negative&quot;);

flatMap(safeSqrt, Ok(4.0)) == Ok(2.0);
flatMap(safeSqrt, Error(&quot;invalid float&quot;)) == Error(&quot;invalid float&quot;);</code></pre><p>Note: `flatMap()` is the same as `bind()`, except with the arguments in reverse order.</p></dd></dl><dl><dt class="spec value" id="val-flatten"><a href="#val-flatten" class="anchor"></a><code><span class="keyword">let</span> flatten: a. <a href="#type-t">t</a><span>(<a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span>;</code></dt><dd><p>* Flattens a nested Result one time.</p></dd></dl><dl><dt class="spec value" id="val-alt"><a href="#val-alt" class="anchor"></a><code><span class="keyword">let</span> alt: a e. <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span>;</code></dt><dd><p>`alt(r1, r2)` takes two `Result` arguments. If both are `Ok(..)`, the first one is returned. If only one is `Ok(..)`, it is returned. If both are `Error(..)`, the last one is returned.</p><p>### Example ```re alt(Ok(2), Ok(3)) == Ok(2); alt(Error(&quot;bad&quot;), Ok(3)) == Ok(3); alt(Ok(2), Error(&quot;worse&quot;)) == Ok(2); alt(Error(&quot;bad&quot;), Error(&quot;worse&quot;)) == Error(&quot;worse&quot;); ```</p></dd></dl><dl><dt class="spec value" id="val-align"><a href="#val-align" class="anchor"></a><code><span class="keyword">let</span> align: a b e. <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'b</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(Relude_Ior_Type.t<span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span>, <span class="type-var">'e</span>)</span>;</code></dt><dd><p>* Converts two results into a result where either side or both sides have succeded, or a result that * fails if both sides failed.</p></dd></dl><dl><dt class="spec value" id="val-alignWith"><a href="#val-alignWith" class="anchor"></a><code><span class="keyword">let</span> alignWith: a b c e. <span>(Relude_Ior_Type.t<span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <span>=&gt;</span> <span class="type-var">'c</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'b</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'c</span>, <span class="type-var">'e</span>)</span>;</code></dt><dd><p>Similar to map2, but captures successful values from either or both sides</p></dd></dl><dl><dt class="spec value" id="val-catchError"><a href="#val-catchError" class="anchor"></a><code><span class="keyword">let</span> catchError: a e1 e2. <span>(<span class="type-var">'e1</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e2</span>)</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e1</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e2</span>)</span>;</code></dt><dd><p>`catchError(f, r)` returns `f(e)` when `r` is of the form `Error(e)`; otherwise it returns `r` (an `Ok` value) unchanged.</p><pre><code class="ml">let labelMessage = s =&gt; &quot;Attn: &quot; ++ s;

catchError(labelMessage, Ok(2)) == Ok(2);
catchError(labelMessage, Error(&quot;not even&quot;)) == Error(&quot;Attn: not even&quot;);</code></pre></dd></dl><dl><dt class="spec value" id="val-handleError"><a href="#val-handleError" class="anchor"></a><code><span class="keyword">let</span> handleError: a e. <span>(<span class="type-var">'e</span> <span>=&gt;</span> <span class="type-var">'a</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, Relude_Void.t)</span>;</code></dt><dd><p>* `handleError(f, r)` converts errors into successful values, and returns a * Result where the error channel is voided, to indicate that the error has * been handled</p></dd></dl><dl><dt class="spec value" id="val-mapHandleError"><a href="#val-mapHandleError" class="anchor"></a><code><span class="keyword">let</span> mapHandleError: a e b. <span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span>)</span> <span>=&gt;</span> <span>(<span class="type-var">'e</span> <span>=&gt;</span> <span class="type-var">'b</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'b</span>, Relude_Void.t)</span>;</code></dt><dd><p>* Maps the success channel and handles an error on the error channel to end up with an * Result of a new type with a voided error channel</p></dd></dl><dl><dt class="spec value" id="val-recover"><a href="#val-recover" class="anchor"></a><code><span class="keyword">let</span> recover: a e. <span class="type-var">'a</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span>;</code></dt><dd><p>`recover(goodValue, result)` returns `result` if it is of the form `Ok(..)`. If `result` is of the form `Error(..)`, `recover` returns `Ok(goodValue)`.</p><pre><code class="ml">let safeAvg = (total, n): Relude.Result.t(float, string) =&gt; {
  if (n &gt; 0) {
    Ok(total /. float_of_int(n));
  } else {
    Error(&quot;Cannot calcuate average&quot;);
  };
};

recover(0.0, safeAvg(32.0, 4)) == Ok(8.0);
recover(0.0, safeAvg(0.0, 0)) == Ok(0.0);</code></pre></dd></dl><dl><dt class="spec value" id="val-fromOption"><a href="#val-fromOption" class="anchor"></a><code><span class="keyword">let</span> fromOption: a e. <span class="type-var">'e</span> <span>=&gt;</span> option(<span class="type-var">'a</span>) <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span>;</code></dt><dd><p>`fromOption(defaultError, opt)` converts a value of the form `Some(v)` to `Ok(v)`, and converts `None` to `Error(defaultError)`.</p><pre><code class="ml">fromOption(&quot;bad value&quot;, Some(3)) == Ok(3);
fromOption(&quot;bad value&quot;, None) == Error(&quot;bad value&quot;);</code></pre></dd></dl><dl><dt class="spec value" id="val-fromOptionLazy"><a href="#val-fromOptionLazy" class="anchor"></a><code><span class="keyword">let</span> fromOptionLazy: a e. <span>(unit <span>=&gt;</span> <span class="type-var">'e</span>)</span> <span>=&gt;</span> option(<span class="type-var">'a</span>) <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span>;</code></dt><dd><p>`fromOptionLazy(defaultFcn, opt)` converts a value of the form `Some(v)` to `Ok(v)`, and converts `None` to `Error(defaultFcn())`, which takes no arguments.</p><p>This is called a *lazy* function because the default value is not calculated unless it is required.</p><pre><code class="ml">let defaultErr = () =&gt; &quot;bad value&quot;;
fromOptionLazy(defaultErr, Some(3)) == Ok(3);
fromOptionLazy(defaultErr, None) == Error(&quot;bad value&quot;);</code></pre></dd></dl><dl><dt class="spec value" id="val-eqBy"><a href="#val-eqBy" class="anchor"></a><code><span class="keyword">let</span> eqBy: a e. <span>(<span class="type-var">'e</span> <span>=&gt;</span> <span class="type-var">'e</span> <span>=&gt;</span> bool)</span> <span>=&gt;</span> <span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'a</span> <span>=&gt;</span> bool)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> bool;</code></dt><dd><p>`eqBy(errorEq, okEq, a, b)` compares `a` and `b` for equality as follows:</p><p>If both are of the form `Ok(..)` and `Ok(..)`, `eqBy` calls `okEq()` with their values and returns a boolean depending on whether they are equal or not.</p><p>If both are of the form `Error(..)`, `eqBy` calls `errorEq()` with their values and returns a boolean depending on whether they are equal or not.</p><p>In all other cases, `eqBy()` returns `false`.</p><pre><code class="ml">let clockEqual = (c1, c2) =&gt; c1 mod 12 == c2 mod 12;
let strEqual = (c1, c2) =&gt; c1 == c2;

eqBy(strEqual, clockEqual, Ok(14), Ok(2)) == true;
eqBy(strEqual, clockEqual, Ok(14), Ok(3)) == false;
eqBy(strEqual, clockEqual, Error(&quot;not an integer&quot;), Error(&quot;not an integer&quot;)) == true;
eqBy(strEqual, clockEqual, Error(&quot;not an integer&quot;), Error(&quot;not positive&quot;)) == false;
eqBy(strEqual, clockEqual, Ok(14), Error(&quot;not positive&quot;)) == false;
eqBy(strEqual, clockEqual, Error(&quot;not an integer&quot;), Ok(2)) == false;</code></pre></dd></dl><dl><dt class="spec value" id="val-tries"><a href="#val-tries" class="anchor"></a><code><span class="keyword">let</span> tries: a. <span>(unit <span>=&gt;</span> <span class="type-var">'a</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, exn)</span>;</code></dt><dd><p>`tries(f)` calls function `f()`, which takes no arguments and returns some value `retVal`. If the call succeeds, the result of `tries()` is `Ok(retVal)`. If it generates an exception, the value is `Error(exception)`.</p><pre><code class="ml">tries(() =&gt; int_of_string(&quot;37&quot;)) == Ok(37);
tries(() =&gt; int_of_string(&quot;four&quot;)); // returns an exn</code></pre></dd></dl><dl><dt class="spec value" id="val-triesAsString"><a href="#val-triesAsString" class="anchor"></a><code><span class="keyword">let</span> triesAsString: a. <span>(unit <span>=&gt;</span> <span class="type-var">'a</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, Js.String.t)</span>;</code></dt><dd><p>`triesAsString(f)` calls function `f()`, which takes no arguments and returns some value `retVal`. If the call succeeds, the result of `tries()` is `Ok(retVal)`. If it generates an exception, the value is `Error(exceptionStr)`, where `exceptionStr` is the string representation of the exception.</p><pre><code class="ml">triesAsString(() =&gt; int_of_string(&quot;37&quot;)) == Ok(37);
triesAsString(() =&gt; int_of_string(&quot;four&quot;)) ==
  Error(&quot;Failure,-2,int_of_string&quot;);</code></pre></dd></dl><dl><dt class="spec value" id="val-toValidation"><a href="#val-toValidation" class="anchor"></a><code><span class="keyword">let</span> toValidation: Pervasives.result<span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <span>=&gt;</span> Relude_Validation.t<span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span>;</code></dt><dd><p>`toValidation(result)` converts `Ok(val)` to `VOk(val)` and `Error(err)` to `VError(err)`.</p></dd></dl><dl><dt class="spec value" id="val-fromValidation"><a href="#val-fromValidation" class="anchor"></a><code><span class="keyword">let</span> fromValidation: Relude_Validation.t<span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <span>=&gt;</span> Pervasives.result<span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span>;</code></dt><dd><p>`fromValidation(vResult)` converts `VOk(val)` to `Ok(val)` and `VError(err)` to `Error(err)`.</p></dd></dl><dl><dt class="spec value" id="val-toValidationNel"><a href="#val-toValidationNel" class="anchor"></a><code><span class="keyword">let</span> toValidationNel: <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> Relude_Validation.t<span>(<span class="type-var">'a</span>, Relude_NonEmpty.List.t(<span class="type-var">'e</span>))</span>;</code></dt><dd><p>`toValidationNel(vResult)` converts `Ok(val)` to `VOk(val)` and `Error(err)` to `VError(<code>err</code>)`, where the list is of type `Relude.NonEmpty.List`.</p><p>### Example ```re toValidationNel(Ok(1066)) == Relude.Validation.VOk(1066); toValidationNel(Error(&quot;not odd&quot;)) == Relude.Validation.VError( Relude.NonEmpty.List.pure(&quot;not odd&quot;)); ```</p><p>You use this function when you have a `Result` type that you wish to use with `Validation` in order to accumulate a list of errors.</p></dd></dl><dl><dt class="spec value" id="val-toValidationNea"><a href="#val-toValidationNea" class="anchor"></a><code><span class="keyword">let</span> toValidationNea: <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> Relude_Validation.t<span>(<span class="type-var">'a</span>, Relude_NonEmpty.Array.t(<span class="type-var">'e</span>))</span>;</code></dt><dd><p>`toValidationNea(vResult)` converts `Ok(val)` to `VOk(val)` and `Error(err)` to `VError(<code>|err|</code>)`, where the array is of type `Relude.NonEmpty.Array`.</p><p>### Example ```re toValidationNea(Ok(1066)) == Relude.Validation.VOk(1066); toValidationNea(Error(&quot;not odd&quot;)) == Relude.Validation.VError( Relude.NonEmpty.Array.pure(&quot;not odd&quot;)); toValidationNea(Error(&quot;not odd&quot;)); ```</p><p>You use this function when you have a `Result` type that you wish to use with `Validation` in order to accumulate an array of errors.</p></dd></dl><div class="spec module" id="module-Bifunctor"><a href="#module-Bifunctor" class="anchor"></a><code><span class="keyword">module</span> Bifunctor: BsBastet.Interface.BIFUNCTOR <span class="keyword">with</span> <span class="keyword">type</span> <a href="#module-Bifunctor">Bifunctor</a>.t('a, 'e) = <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span>;</code></div><dl><dt class="spec value" id="val-bimap"><a href="#val-bimap" class="anchor"></a><code><span class="keyword">let</span> bimap: <span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span>)</span> <span>=&gt;</span> <span>(<span class="type-var">'c</span> <span>=&gt;</span> <span class="type-var">'d</span>)</span> <span>=&gt;</span> <a href="#module-Bifunctor">Bifunctor</a>.t<span>(<span class="type-var">'a</span>, <span class="type-var">'c</span>)</span> <span>=&gt;</span> <a href="#module-Bifunctor">Bifunctor</a>.t<span>(<span class="type-var">'b</span>, <span class="type-var">'d</span>)</span>;</code></dt></dl><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> { ... }<span class="keyword">;</span></code></span></summary><dl><dt class="spec value" id="val-mapLeft"><a href="#val-mapLeft" class="anchor"></a><code><span class="keyword">let</span> mapLeft: <span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'c</span>)</span> <span>=&gt;</span> <a href="#module-Bifunctor">Bifunctor</a>.t<span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <span>=&gt;</span> <a href="#module-Bifunctor">Bifunctor</a>.t<span>(<span class="type-var">'c</span>, <span class="type-var">'b</span>)</span>;</code></dt><dt class="spec value" id="val-mapRight"><a href="#val-mapRight" class="anchor"></a><code><span class="keyword">let</span> mapRight: <span>(<span class="type-var">'b</span> <span>=&gt;</span> <span class="type-var">'d</span>)</span> <span>=&gt;</span> <a href="#module-Bifunctor">Bifunctor</a>.t<span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <span>=&gt;</span> <a href="#module-Bifunctor">Bifunctor</a>.t<span>(<span class="type-var">'a</span>, <span class="type-var">'d</span>)</span>;</code></dt><dt class="spec value" id="val-mapError"><a href="#val-mapError" class="anchor"></a><code><span class="keyword">let</span> mapError: <span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span>)</span> <span>=&gt;</span> <a href="#module-Bifunctor">Bifunctor</a>.t<span>(<span class="type-var">'c</span>, <span class="type-var">'a</span>)</span> <span>=&gt;</span> <a href="#module-Bifunctor">Bifunctor</a>.t<span>(<span class="type-var">'c</span>, <span class="type-var">'b</span>)</span>;</code></dt></dl></details></div></div></div><div class="spec module" id="module-Bifoldable"><a href="#module-Bifoldable" class="anchor"></a><code><span class="keyword">module</span> Bifoldable: BsBastet.Interface.BIFOLDABLE <span class="keyword">with</span> <span class="keyword">type</span> <a href="#module-Bifoldable">Bifoldable</a>.t('a, 'e) = <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span>;</code></div><dl><dt class="spec value" id="val-bifoldLeft"><a href="#val-bifoldLeft" class="anchor"></a><code><span class="keyword">let</span> bifoldLeft: <span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span> <span>=&gt;</span> <span class="type-var">'a</span>)</span> <span>=&gt;</span> <span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'c</span> <span>=&gt;</span> <span class="type-var">'a</span>)</span> <span>=&gt;</span> <span class="type-var">'a</span> <span>=&gt;</span> <a href="#module-Bifoldable">Bifoldable</a>.t<span>(<span class="type-var">'b</span>, <span class="type-var">'c</span>)</span> <span>=&gt;</span> <span class="type-var">'a</span>;</code></dt><dt class="spec value" id="val-bifoldRight"><a href="#val-bifoldRight" class="anchor"></a><code><span class="keyword">let</span> bifoldRight: <span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span> <span>=&gt;</span> <span class="type-var">'b</span>)</span> <span>=&gt;</span> <span>(<span class="type-var">'c</span> <span>=&gt;</span> <span class="type-var">'b</span> <span>=&gt;</span> <span class="type-var">'b</span>)</span> <span>=&gt;</span> <span class="type-var">'b</span> <span>=&gt;</span> <a href="#module-Bifoldable">Bifoldable</a>.t<span>(<span class="type-var">'a</span>, <span class="type-var">'c</span>)</span> <span>=&gt;</span> <span class="type-var">'b</span>;</code></dt></dl><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> { ... }<span class="keyword">;</span></code></span></summary></details></div></div></div><dl><dt class="spec module" id="module-WithError"><a href="#module-WithError" class="anchor"></a><code><span class="keyword">module</span> <a href="WithError">WithError</a>:  (<a href="WithError#argument-1-E">E</a>: BsBastet.Interface.TYPE) <span>=&gt;</span> { ... };</code></dt><dd><p>* Because Result is a bi-functor, we need to capture the error type in order * to implement many of the single-type-parameter typeclasses. Doing it like * this allows us to unlock a bunch of stuff at once using a single module * functor.</p></dd></dl></div></body></html>