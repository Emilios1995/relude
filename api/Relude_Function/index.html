<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Relude_Function (api.Relude_Function)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../">Up</a> – <a href="../">api</a> &#x00BB; Relude_Function</nav><h1>Module <code>Relude_Function</code></h1></header><dl><dt class="spec value" id="val-identity"><a href="#val-identity" class="anchor"></a><code><span class="keyword">let</span> identity: a. <span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'a</span>;</code></dt><dd><p>`Relude.Function` contains many core functions like `identity`, `flip`, `compose`, `andThen`, and some of the associated infix operators like `&lt;&lt;` (`compose`) and `&gt;&gt;` (`andThen`).</p><p>It also defines some typeclass instances like `Functor`, `Apply`, `Monad`, etc. for the `'r =&gt; 'a` function type.</p><p>`identity(x)` returns `x`. This is useful when you need to supply a function but don’t want to transform any values.</p></dd></dl><dl><dt class="spec value" id="val-id"><a href="#val-id" class="anchor"></a><code><span class="keyword">let</span> id: a. <span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'a</span>;</code></dt><dd><p>`id` is a synonym for `identity`.</p></dd></dl><dl><dt class="spec value" id="val-const"><a href="#val-const" class="anchor"></a><code><span class="keyword">let</span> const: a b. <span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span> <span>=&gt;</span> <span class="type-var">'a</span>;</code></dt><dd><p>`const(x, y)` returns `x`.</p><pre><code class="ml">const(3, &quot;ignore&quot;) == 3;
const(&quot;keep&quot;, -1) == &quot;keep&quot;;</code></pre></dd></dl><dl><dt class="spec value" id="val-flip"><a href="#val-flip" class="anchor"></a><code><span class="keyword">let</span> flip: a b c. <span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span> <span>=&gt;</span> <span class="type-var">'c</span>)</span> <span>=&gt;</span> <span class="type-var">'b</span> <span>=&gt;</span> <span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'c</span>;</code></dt><dd><p>`flip(f, a, b)` has a two-parameter function `f()` as its first parameter. It calls `f(b, a)`, thus “flipping“ the arguments to `f()`.</p><pre><code class="ml">let formula = (x, y) =&gt; {x + 2 * y};
formula(3, 5) == 13;
flip(formula, 5, 3) == 13;</code></pre></dd></dl><dl><dt class="spec value" id="val-compose"><a href="#val-compose" class="anchor"></a><code><span class="keyword">let</span> compose: a b c. <span>(<span class="type-var">'b</span> <span>=&gt;</span> <span class="type-var">'c</span>)</span> <span>=&gt;</span> <span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span>)</span> <span>=&gt;</span> <span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'c</span>;</code></dt><dd><p>`compose(f, g, a)` is the equivalent of `f(g(a))`.</p><pre><code class="ml">let square = (x) =&gt; {x * x};
let double = (x) =&gt; {2 * x};
compose(square, double, 3) == 36;
compose(double, square, 3) == 18;</code></pre></dd></dl><dl><dt class="spec value" id="val-flipCompose"><a href="#val-flipCompose" class="anchor"></a><code><span class="keyword">let</span> flipCompose: a b c. <span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span>)</span> <span>=&gt;</span> <span>(<span class="type-var">'b</span> <span>=&gt;</span> <span class="type-var">'c</span>)</span> <span>=&gt;</span> <span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'c</span>;</code></dt><dd><p>`flipCompose(f, g, a)` is the equivalent of `g(f(a))`.</p><pre><code class="ml">let square = (x) =&gt; {x * x};
let double = (x) =&gt; {2 * x};
flipCompose(square, double, 3) == 18;
flipCompose(double, square, 3) == 36;</code></pre></dd></dl><dl><dt class="spec value" id="val-andThen"><a href="#val-andThen" class="anchor"></a><code><span class="keyword">let</span> andThen: a b c. <span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span>)</span> <span>=&gt;</span> <span>(<span class="type-var">'b</span> <span>=&gt;</span> <span class="type-var">'c</span>)</span> <span>=&gt;</span> <span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'c</span>;</code></dt><dd><p>`andThen` is a synonym for `flipCompose`</p><p>You can use this synonym with the “pipe first“ operator:</p><pre><code class="ml">let square = (x) =&gt; {x * x};
let double = (x) =&gt; {2 * x};
let addFive = (x) =&gt; {x + 5};

let formula = square -&gt; andThen(double) -&gt; andThen(addFive);
formula(3);</code></pre></dd></dl><dl><dt class="spec value" id="val-curry2"><a href="#val-curry2" class="anchor"></a><code><span class="keyword">let</span> curry2: a b c. <span>(<span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <span>=&gt;</span> <span class="type-var">'c</span>)</span> <span>=&gt;</span> <span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span> <span>=&gt;</span> <span class="type-var">'c</span>;</code></dt><dd><p>Converts a function that takes a tuple 2 as an argument to a normal curried function.</p></dd></dl><dl><dt class="spec value" id="val-curry3"><a href="#val-curry3" class="anchor"></a><code><span class="keyword">let</span> curry3: a b c d. <span>(<span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'c</span>)</span> <span>=&gt;</span> <span class="type-var">'d</span>)</span> <span>=&gt;</span> <span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span> <span>=&gt;</span> <span class="type-var">'c</span> <span>=&gt;</span> <span class="type-var">'d</span>;</code></dt><dd><p>Converts a function that takes a tuple-3 as an argument to a normal curried function.</p></dd></dl><dl><dt class="spec value" id="val-curry4"><a href="#val-curry4" class="anchor"></a><code><span class="keyword">let</span> curry4: a b c d e. <span>(<span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'c</span>, <span class="type-var">'d</span>)</span> <span>=&gt;</span> <span class="type-var">'e</span>)</span> <span>=&gt;</span> <span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span> <span>=&gt;</span> <span class="type-var">'c</span> <span>=&gt;</span> <span class="type-var">'d</span> <span>=&gt;</span> <span class="type-var">'e</span>;</code></dt><dd><p>Converts a function that takes a tuple-4 as an argument to a normal curried function.</p></dd></dl><dl><dt class="spec value" id="val-curry5"><a href="#val-curry5" class="anchor"></a><code><span class="keyword">let</span> curry5: a b c d e f. <span>(<span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'c</span>, <span class="type-var">'d</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <span class="type-var">'f</span>)</span> <span>=&gt;</span> <span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span> <span>=&gt;</span> <span class="type-var">'c</span> <span>=&gt;</span> <span class="type-var">'d</span> <span>=&gt;</span> <span class="type-var">'e</span> <span>=&gt;</span> <span class="type-var">'f</span>;</code></dt><dd><p>Converts a function that takes a tuple-5 as an argument to a normal curried function.</p></dd></dl><dl><dt class="spec value" id="val-uncurry2"><a href="#val-uncurry2" class="anchor"></a><code><span class="keyword">let</span> uncurry2: a b c. <span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span> <span>=&gt;</span> <span class="type-var">'c</span>)</span> <span>=&gt;</span> <span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <span>=&gt;</span> <span class="type-var">'c</span>;</code></dt><dd><p>Converts a normal curried function of two arguments to a function that takes a tuple-2 as an argument.</p></dd></dl><dl><dt class="spec value" id="val-uncurry3"><a href="#val-uncurry3" class="anchor"></a><code><span class="keyword">let</span> uncurry3: a b c d. <span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span> <span>=&gt;</span> <span class="type-var">'c</span> <span>=&gt;</span> <span class="type-var">'d</span>)</span> <span>=&gt;</span> <span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'c</span>)</span> <span>=&gt;</span> <span class="type-var">'d</span>;</code></dt><dd><p>Converts a normal curried function of 3 arguments to a function that takes a tuple-3 as an argument.</p></dd></dl><dl><dt class="spec value" id="val-uncurry4"><a href="#val-uncurry4" class="anchor"></a><code><span class="keyword">let</span> uncurry4: a b c d e. <span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span> <span>=&gt;</span> <span class="type-var">'c</span> <span>=&gt;</span> <span class="type-var">'d</span> <span>=&gt;</span> <span class="type-var">'e</span>)</span> <span>=&gt;</span> <span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'c</span>, <span class="type-var">'d</span>)</span> <span>=&gt;</span> <span class="type-var">'e</span>;</code></dt><dd><p>Converts a normal curried function of 4 arguments to a function that takes a tuple-4 as an argument.</p></dd></dl><dl><dt class="spec value" id="val-uncurry5"><a href="#val-uncurry5" class="anchor"></a><code><span class="keyword">let</span> uncurry5: a b c d e f. <span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span> <span>=&gt;</span> <span class="type-var">'c</span> <span>=&gt;</span> <span class="type-var">'d</span> <span>=&gt;</span> <span class="type-var">'e</span> <span>=&gt;</span> <span class="type-var">'f</span>)</span> <span>=&gt;</span> <span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'c</span>, <span class="type-var">'d</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <span class="type-var">'f</span>;</code></dt><dd><p>Converts a normal curried function of 5 arguments to a function that takes a tuple-5 as an argument.</p></dd></dl><dl><dt class="spec value" id="val-map"><a href="#val-map" class="anchor"></a><code><span class="keyword">let</span> map: a b r. <span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span>)</span> <span>=&gt;</span> <span>(<span class="type-var">'r</span> <span>=&gt;</span> <span class="type-var">'a</span>)</span> <span>=&gt;</span> <span class="type-var">'r</span> <span>=&gt;</span> <span class="type-var">'b</span>;</code></dt><dd><p>`map` is a synonym for `compose` and is the equivalent of `f(g(a))`.</p><pre><code class="ml">let square = (x) =&gt; {x * x};
let double = (x) =&gt; {2 * x};
map(square, double, 3) == 36;
map(double, square, 3) == 18;</code></pre></dd></dl><dl><dt class="spec value" id="val-apply"><a href="#val-apply" class="anchor"></a><code><span class="keyword">let</span> apply: a b r. <span>(<span class="type-var">'r</span> <span>=&gt;</span> <span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span>)</span> <span>=&gt;</span> <span>(<span class="type-var">'r</span> <span>=&gt;</span> <span class="type-var">'a</span>)</span> <span>=&gt;</span> <span class="type-var">'r</span> <span>=&gt;</span> <span class="type-var">'b</span>;</code></dt><dd><p>In `apply(hof, f, a)`, `hof` is a higher-order function that takes one argument and returns a new function that also takes one argument.</p><p>The result of `apply()` is equivalent to:</p><pre><code class="ml">let g = hof(a);
g(f(a))</code></pre><pre><code class="ml">// This is the higher-order function
let showResult = (n) =&gt; {
  (x: float) =&gt; {&quot;input &quot; ++ string_of_int(n)
    ++ &quot; yields &quot; ++ Js.Float.toString(x)
  }
};

let cube = (x) =&gt; { float_of_int(x * x * x) };

apply(showResult, cube, 5) == &quot;input 5 yields 125&quot;;</code></pre></dd></dl><dl><dt class="spec value" id="val-pure"><a href="#val-pure" class="anchor"></a><code><span class="keyword">let</span> pure: a r. <span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'r</span> <span>=&gt;</span> <span class="type-var">'a</span>;</code></dt><dd><p>`pure` is a synonym for `const`</p></dd></dl><dl><dt class="spec value" id="val-bind"><a href="#val-bind" class="anchor"></a><code><span class="keyword">let</span> bind: a b r. <span>(<span class="type-var">'r</span> <span>=&gt;</span> <span class="type-var">'a</span>)</span> <span>=&gt;</span> <span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'r</span> <span>=&gt;</span> <span class="type-var">'b</span>)</span> <span>=&gt;</span> <span class="type-var">'r</span> <span>=&gt;</span> <span class="type-var">'b</span>;</code></dt><dd><p>In `bind(f, hof, a)`, `hof` is a higher-order function that takes one argument and returns a new function that also takes one argument.</p><p>The result of `bind()` is equivalent to:</p><pre><code class="ml">let g = hof(f(a));
g(a)</code></pre><pre><code class="ml">// This is the higher-order function
let showResult = (x) =&gt; {
  (n: int) =&gt; {&quot;input &quot; ++ string_of_int(n)
    ++ &quot; yields &quot; ++ Js.Float.toString(x)
  }
};

let cube = (x) =&gt; { float_of_int(x * x * x) };

bind(cube, showResult, 5) == &quot;input 5 yields 125&quot;;</code></pre></dd></dl><dl><dt class="spec value" id="val-flatMap"><a href="#val-flatMap" class="anchor"></a><code><span class="keyword">let</span> flatMap: a b r. <span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'r</span> <span>=&gt;</span> <span class="type-var">'b</span>)</span> <span>=&gt;</span> <span>(<span class="type-var">'r</span> <span>=&gt;</span> <span class="type-var">'a</span>)</span> <span>=&gt;</span> <span class="type-var">'r</span> <span>=&gt;</span> <span class="type-var">'b</span>;</code></dt><dd><p>In `flatMap(hof, f, a)`, `hof` is a higher-order function that takes one argument and returns a new function that also takes one argument. It is the same as `bind()`, but with the first two arguments in reverse order.</p><p>The result of `flatMap()` is equivalent to:</p><pre><code class="ml">let g = hof(f(a));
g(a)</code></pre><pre><code class="ml">// This is the higher-order function
let showResult = (x) =&gt; {
  (n: int) =&gt; {&quot;input &quot; ++ string_of_int(n)
    ++ &quot; yields &quot; ++ Js.Float.toString(x)
  }
};

let cube = (x) =&gt; { float_of_int(x * x * x) };

flatMap(showResult, cube, 5) == &quot;input 5 yields 125&quot;;</code></pre></dd></dl><dl><dt class="spec value" id="val-memoize0"><a href="#val-memoize0" class="anchor"></a><code><span class="keyword">let</span> memoize0: <span>(unit <span>=&gt;</span> <span class="type-var">'a</span>)</span> <span>=&gt;</span> unit <span>=&gt;</span> <span class="type-var">'a</span>;</code></dt><dd><p>`memoize0` takes a `unit =&gt; 'a` function and returns a new function which once called, will store the result produced and return that cached result for each successive call.</p></dd></dl><dl><dt class="spec value" id="val-memoize1"><a href="#val-memoize1" class="anchor"></a><code><span class="keyword">let</span> memoize1: <span>makeKey:<span>(<span class="type-var">'a</span> <span>=&gt;</span> string)</span></span> <span>=&gt;</span> <span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span>)</span> <span>=&gt;</span> <span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span>;</code></dt><dd><p>`memoize1` takes a `'a =&gt; 'b` function and returns a new `'a =&gt; 'b` function which once called, stores the result produced by the given function in a closure-based cache, using a cache key created by the function `makeKey`</p><p>All successive calls to the function for input values that resolve to the same cache key will return the cached result.</p></dd></dl><dl><dt class="spec value" id="val-before"><a href="#val-before" class="anchor"></a><code><span class="keyword">let</span> before: <span>times:int</span> <span>=&gt;</span> <span>(unit <span>=&gt;</span> <span class="type-var">'a</span>)</span> <span>=&gt;</span> unit <span>=&gt;</span> <span class="type-var">'a</span>;</code></dt><dd><p>Takes a function and returns a new function which when called, will allow the first `times` calls to invoke the given function, and any successive calls will be suppressed and the last result will be returned.</p></dd></dl><dl><dt class="spec value" id="val-after"><a href="#val-after" class="anchor"></a><code><span class="keyword">let</span> after: <span>times:int</span> <span>=&gt;</span> <span>(unit <span>=&gt;</span> <span class="type-var">'a</span>)</span> <span>=&gt;</span> unit <span>=&gt;</span> option(<span class="type-var">'a</span>);</code></dt><dd><p>Takes a function and returns a new function that when called, will suppress the first `times` invocations</p></dd></dl><dl><dt class="spec value" id="val-once"><a href="#val-once" class="anchor"></a><code><span class="keyword">let</span> once: <span>(unit <span>=&gt;</span> <span class="type-var">'a</span>)</span> <span>=&gt;</span> unit <span>=&gt;</span> <span class="type-var">'a</span>;</code></dt><dd><p>Takes a function and returns a new function which will invoke the given function once, and any successive calls will be suppressed, returning the value of the first call.</p></dd></dl><dl><dt class="spec value" id="val-wrap"><a href="#val-wrap" class="anchor"></a><code><span class="keyword">let</span> wrap: <span>before:<span>(<span class="type-var">'i</span> <span>=&gt;</span> <span class="type-var">'a</span>)</span></span> <span>=&gt;</span> <span>after:<span>(<span class="type-var">'b</span> <span>=&gt;</span> <span class="type-var">'o</span>)</span></span> <span>=&gt;</span> <span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span>)</span> <span>=&gt;</span> <span class="type-var">'i</span> <span>=&gt;</span> <span class="type-var">'o</span>;</code></dt><dd><p>Takes a function from `'a =&gt; 'b` and a function from `'i =&gt; 'a` to modify the input, and a function `'b =&gt; 'o` to modify the output, and returns a new function `'i =&gt; 'o`</p></dd></dl><dl><dt class="spec value" id="val-negate"><a href="#val-negate" class="anchor"></a><code><span class="keyword">let</span> negate: <span>(<span class="type-var">'a</span> <span>=&gt;</span> bool)</span> <span>=&gt;</span> <span class="type-var">'a</span> <span>=&gt;</span> bool;</code></dt><dd><p>Takes a predicate function, and returns a new predicate function which negates the given predicate.</p></dd></dl><dl><dt class="spec module" id="module-Infix"><a href="#module-Infix" class="anchor"></a><code><span class="keyword">module</span> <a href="Infix">Infix</a>: { ... };</code></dt><dd><p>The `Infix` submodule provides two infix operators for function composition.</p></dd></dl><div class="spec module" id="module-WithArgument"><a href="#module-WithArgument" class="anchor"></a><code><span class="keyword">module</span> <a href="WithArgument">WithArgument</a>:  (<a href="WithArgument#argument-1-R">R</a>: BsBastet.Interface.TYPE) <span>=&gt;</span> { ... };</code></div></div></body></html>