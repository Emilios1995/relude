<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Relude_String (api.Relude_String)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../">Up</a> – <a href="../">api</a> &#x00BB; Relude_String</nav><h1>Module <code>Relude_String</code></h1></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code><code> = string</code>;</dt></dl><dl><dt class="spec value" id="val-empty"><a href="#val-empty" class="anchor"></a><code><span class="keyword">let</span> empty: string;</code></dt><dd><p>Returns the empty string</p></dd></dl><dl><dt class="spec value" id="val-length"><a href="#val-length" class="anchor"></a><code><span class="keyword">let</span> length: string <span>=&gt;</span> int;</code></dt><dd><p>`length(str)` returns the length of the string. Since this function calls the JavaScript `String.length` function, it works properly with Unicode characters.</p><pre><code class="ml">length(&quot;example&quot;) == 7;
length({js|Glück|js}) == 5;
length({js|대한민국|js}) == 4;</code></pre></dd></dl><dl><dt class="spec value" id="val-isEmpty"><a href="#val-isEmpty" class="anchor"></a><code><span class="keyword">let</span> isEmpty: string <span>=&gt;</span> bool;</code></dt><dd><p>`isEmpty(str)` returns `true` if `str` is the empty string `&quot;&quot;`; `false` otherwise.</p></dd></dl><dl><dt class="spec value" id="val-isNonEmpty"><a href="#val-isNonEmpty" class="anchor"></a><code><span class="keyword">let</span> isNonEmpty: string <span>=&gt;</span> bool;</code></dt><dd><p>`isNotEmpty(str)` returns `true` if `str` is not the empty string `&quot;&quot;`; `false` if it is empty.</p></dd></dl><dl><dt class="spec value" id="val-isNotEmpty"><a href="#val-isNotEmpty" class="anchor"></a><code><span class="keyword">let</span> isNotEmpty: string <span>=&gt;</span> bool;</code></dt><dd><p>Alias for isNonEmpty</p></dd></dl><dl><dt class="spec value" id="val-toNonEmpty"><a href="#val-toNonEmpty" class="anchor"></a><code><span class="keyword">let</span> toNonEmpty: string <span>=&gt;</span> option(string);</code></dt><dd><p>`toNonEmpty(str)` returns `Some(str)` if `str` is not the empty string `&quot;&quot;`. It returns `None` if `str` is the empty string.</p><pre><code class="ml">toNonEmpty(&quot;abc&quot;) == Some(&quot;abc&quot;);
toNonEmpty(&quot;&quot;) == None;</code></pre></dd></dl><dl><dt class="spec value" id="val-trim"><a href="#val-trim" class="anchor"></a><code><span class="keyword">let</span> trim: string <span>=&gt;</span> string;</code></dt><dd><p>`trim(str)` returns a new string with leading and trailing whitespace (blank, tab, newline, non-breaking space and others as described in &lt;https://www.ecma-international.org/ecma-262/5.1/#sec-7.2&gt;) removed from `s`.</p><pre><code class="ml">trim(&quot;  abc  &quot;) == &quot;abc&quot;;
trim(&quot;  abc def  &quot;) == &quot;abc def&quot;;
trim({js|\n\u00a0 \t abc \f\r \t|js}) == &quot;abc&quot;;</code></pre></dd></dl><dl><dt class="spec value" id="val-isWhitespace"><a href="#val-isWhitespace" class="anchor"></a><code><span class="keyword">let</span> isWhitespace: string <span>=&gt;</span> bool;</code></dt><dd><p>`isWhitespace(str)` returns true if the string consists entirely of whitespace characters as described in &lt;https://www.ecma-international.org/ecma-262/5.1/#sec-7.2&gt;</p><pre><code class="ml">isWhitespace(&quot; \n \t \r  &quot;) == true;
isWhitespace(&quot; \n \t X \r &quot;) == false;</code></pre></dd></dl><dl><dt class="spec value" id="val-isNonWhitespace"><a href="#val-isNonWhitespace" class="anchor"></a><code><span class="keyword">let</span> isNonWhitespace: string <span>=&gt;</span> bool;</code></dt><dd><p>Indicates if the string contains any non-whitespace characters</p></dd></dl><dl><dt class="spec value" id="val-toNonWhitespace"><a href="#val-toNonWhitespace" class="anchor"></a><code><span class="keyword">let</span> toNonWhitespace: string <span>=&gt;</span> option(string);</code></dt><dd><p>`toNonWhiteSpace(str)` returns `Some(str)` if `str` has any non-whitespace characters in it. The function returns `None` if `str` consists entirely of whitespace.</p><pre><code class="ml">toNonWhitespace(&quot;\n\t abc \t\r&quot;) == Some(&quot;\n\t abc \t\r&quot;);
toNonWhitespace(&quot;\t\n  \r&quot;) == None;</code></pre></dd></dl><dl><dt class="spec value" id="val-concat"><a href="#val-concat" class="anchor"></a><code><span class="keyword">let</span> concat: string <span>=&gt;</span> string <span>=&gt;</span> string;</code></dt><dd><p>`concat(str1, str2)` concatenate the two strings, returning a new string.</p><pre><code class="ml">concat(&quot;door&quot;, &quot;bell&quot;) == &quot;doorbell&quot;;
concat(&quot;&quot;, &quot;next&quot;) == &quot;next&quot;;
concat(&quot;first&quot;, &quot;&quot;) == &quot;first&quot;;</code></pre></dd></dl><div class="spec module" id="module-Semigroup"><a href="#module-Semigroup" class="anchor"></a><code><span class="keyword">module</span> Semigroup: BsBastet.Interface.SEMIGROUP <span class="keyword">with</span> <span class="keyword">type</span> <a href="#module-Semigroup">Semigroup</a>.t = string;</code></div><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> { ... }<span class="keyword">;</span></code></span></summary><dl><dt class="spec value" id="val-concatNamed"><a href="#val-concatNamed" class="anchor"></a><code><span class="keyword">let</span> concatNamed: <span>prefix:<a href="#module-Semigroup">Semigroup</a>.t</span> <span>=&gt;</span> <a href="#module-Semigroup">Semigroup</a>.t <span>=&gt;</span> <a href="#module-Semigroup">Semigroup</a>.t;</code></dt></dl></details></div></div></div><div class="spec module" id="module-Monoid"><a href="#module-Monoid" class="anchor"></a><code><span class="keyword">module</span> Monoid: BsBastet.Interface.MONOID <span class="keyword">with</span> <span class="keyword">type</span> <a href="#module-Monoid">Monoid</a>.t = string;</code></div><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> { ... }<span class="keyword">;</span></code></span></summary><div class="spec module" id="module-BsMonoidExtensions"><a href="#module-BsMonoidExtensions" class="anchor"></a><code><span class="keyword">module</span> <a href="BsMonoidExtensions">BsMonoidExtensions</a>: { ... };</code></div><dl><dt class="spec value" id="val-guard"><a href="#val-guard" class="anchor"></a><code><span class="keyword">let</span> guard: bool <span>=&gt;</span> <a href="#module-Monoid">Monoid</a>.t <span>=&gt;</span> <a href="#module-Monoid">Monoid</a>.t;</code></dt><dt class="spec value" id="val-power"><a href="#val-power" class="anchor"></a><code><span class="keyword">let</span> power: <a href="#module-Monoid">Monoid</a>.t <span>=&gt;</span> int <span>=&gt;</span> <a href="#module-Monoid">Monoid</a>.t;</code></dt></dl></details></div></div></div><dl><dt class="spec value" id="val-concatArray"><a href="#val-concatArray" class="anchor"></a><code><span class="keyword">let</span> concatArray: array(string) <span>=&gt;</span> string;</code></dt><dd><p>`concatArray(xs)` returns a new string that is the result of concatenating all the strings in `xs`</p><pre><code class="ml">concatArray([|&quot;cat&quot;, &quot;en&quot;, &quot;ate&quot;|]) == &quot;catenate&quot;;
concatArray([|&quot;chair&quot;, &quot;&quot;, &quot;person&quot;|]) == &quot;chairperson&quot;;
concatArray([| |]) == &quot;&quot;;</code></pre></dd></dl><dl><dt class="spec value" id="val-concatList"><a href="#val-concatList" class="anchor"></a><code><span class="keyword">let</span> concatList: list(string) <span>=&gt;</span> string;</code></dt><dd><p>Like `concatArray`, but for `list`</p></dd></dl><dl><dt class="spec value" id="val-make"><a href="#val-make" class="anchor"></a><code><span class="keyword">let</span> make: <span class="type-var">'a</span> <span>=&gt;</span> string;</code></dt><dd><p>`make(x)` converts `x` to a string. If `x` is not a primitive type such as integer, float, string, or boolean, the result will reflect ReasonML’s internal format for that data type.</p><pre><code class="ml">make(32.5) == &quot;32.5&quot;;
make(1.0e3) == &quot;1000&quot;;
make(true) == &quot;true&quot;;
make(&quot;already a string&quot;) == &quot;already a string&quot;;
make([1, 2, 3, 4]) == &quot;1,2,3,4,0&quot;;
make([|1, 2, 3, 4|]) == &quot;1,2,3,4&quot;;</code></pre></dd></dl><dl><dt class="spec value" id="val-makeWithIndex"><a href="#val-makeWithIndex" class="anchor"></a><code><span class="keyword">let</span> makeWithIndex: int <span>=&gt;</span> <span>(int <span>=&gt;</span> string)</span> <span>=&gt;</span> string;</code></dt><dd><p>`makeWithIndex(n, f)` returns a string that is the result of concatenating `f(0)`, `f(1)`, ... `f(n - 1)`, where function `f()` takes an integer argument and returns a string.</p><pre><code class="ml">let squareChar = (n) =&gt; {fromCharCode(97 + n * n)};
makeWithIndex(4, squareChar) == &quot;abej&quot;;</code></pre></dd></dl><dl><dt class="spec value" id="val-repeat"><a href="#val-repeat" class="anchor"></a><code><span class="keyword">let</span> repeat: int <span>=&gt;</span> string <span>=&gt;</span> string;</code></dt><dd><p>`repeat(n, str)` returns a string consisting of `n` repetitions of `str`.</p><pre><code class="ml">repeat(3, &quot;ha&quot;) == &quot;hahaha&quot;;
repeat(0, &quot;ha&quot;) == &quot;&quot;;
repeat(-1, &quot;ha&quot;) == &quot;&quot;;
repeat(3, &quot;&quot;) == &quot;&quot;;</code></pre></dd></dl><dl><dt class="spec value" id="val-toUpperCase"><a href="#val-toUpperCase" class="anchor"></a><code><span class="keyword">let</span> toUpperCase: string <span>=&gt;</span> string;</code></dt><dd><p>`toUpperCase(str)` converts `str` to upper case using the locale-insensitive case mappings in the Unicode Character Database. Notice that the conversion can expand the number of letters in the result; for example, the German `ß` capitalizes to two `S`es in a row.</p><pre><code class="ml">toUpperCase(&quot;abc&quot;) == &quot;ABC&quot;;
toUpperCase({js|Straße|js}) == {js|STRASSE|js};
toUpperCase({js|σπ|js}) == {js|ΣΠ|js};
toUpperCase({js|πς|js}) == {js|ΠΣ|js}; // sigma in final position</code></pre></dd></dl><dl><dt class="spec value" id="val-toLowerCase"><a href="#val-toLowerCase" class="anchor"></a><code><span class="keyword">let</span> toLowerCase: string <span>=&gt;</span> string;</code></dt><dd><p>`toLowerCase(str)` converts `str` to lower case using the locale-insensitive case mappings in the Unicode Character Database. Notice that the conversion might not lessen the number of letters in the result; for example, in some German words, two `S`es in a row can convert to the single lowercase glyph `ß`, but `toLowerCase()` will not do this transformation..</p><pre><code class="ml">toLowerCase(&quot;ABC&quot;) == &quot;abc&quot;;
toLowerCase({js|STRASSE|js}) == {js|strasse|js};
toLowerCase({js|ΣΠ|js}) == {js|σπ|js};
toLowerCase({js|ΠΣ|js}) == {js|πς|js}; // sigma in final position</code></pre></dd></dl><dl><dt class="spec value" id="val-fromCharCode"><a href="#val-fromCharCode" class="anchor"></a><code><span class="keyword">let</span> fromCharCode: int <span>=&gt;</span> string;</code></dt><dd><p>`fromCharCode(n)` creates a string containing the character corresponding to that number; n ranges from 0 to 65535. If out of range, the lower 16 bits of the value are used. Thus, `fromCharCode(0x1F63A)` gives the same result as `fromCharCode(0xF63A)`.</p><pre><code class="ml">fromCharCode(65) == &quot;A&quot;;
fromCharCode(0x0920) == {js|ठ|js};
fromCharCode(0x3c8) == {js|ψ|js};
fromCharCode(-64568) == {js|ψ|js};</code></pre></dd></dl><dl><dt class="spec value" id="val-charCodeAt"><a href="#val-charCodeAt" class="anchor"></a><code><span class="keyword">let</span> charCodeAt: int <span>=&gt;</span> string <span>=&gt;</span> option(int);</code></dt><dd><p>`charCodeAt(n, str)` returns (optionally) the numeric character code at the given 0-based position in a string. If the provided position is out of the range of the size of the string (too high or negative), `None` is returned.</p><pre><code class="ml">charCodeAt(0, &quot;abc&quot;) == Some(97);
charCodeAt(-1, &quot;abc&quot;) == None;
charCodeAt(0, &quot;&quot;) == None;</code></pre></dd></dl><dl><dt class="spec value" id="val-charAt"><a href="#val-charAt" class="anchor"></a><code><span class="keyword">let</span> charAt: int <span>=&gt;</span> string <span>=&gt;</span> option(string);</code></dt><dd><p>`charAt(n, str)` returns `Some(chStr)`, where `chStr` is a string consisting of the character at location `n` in the string. The first character in a string has position zero.</p><p>If `n` is out of bounds, `charAt()` returns `None`.</p><pre><code class="ml">charAt(0, &quot;abc&quot;) == Some(&quot;a&quot;);
charAt(2, &quot;abc&quot;) == Some(&quot;c&quot;);
charAt(1, {js|대한민국|js}) == Some({js|한|js});
charAt(-1, &quot;abc&quot;) == None;
charAt(3, &quot;abc&quot;) == None;</code></pre></dd></dl><dl><dt class="spec value" id="val-charAtOrEmpty"><a href="#val-charAtOrEmpty" class="anchor"></a><code><span class="keyword">let</span> charAtOrEmpty: int <span>=&gt;</span> string <span>=&gt;</span> string;</code></dt><dd><p>`charAtOrEmpty(n, str)` returns the string containing the character at the given index or the empty string if the index is out of range.</p><pre><code class="ml">charAtOrEmpty(0, &quot;abc&quot;) == &quot;a&quot;;
charAtOrEmpty(0, &quot;&quot;) == &quot;&quot;;
charAtOrEmpty(2, &quot;a&quot;) == &quot;&quot;;
charAtOrEmpty(-1, &quot;abc&quot;) == &quot;&quot;;</code></pre></dd></dl><dl><dt class="spec value" id="val-charAtNullable"><a href="#val-charAtNullable" class="anchor"></a><code><span class="keyword">let</span> charAtNullable: int <span>=&gt;</span> string <span>=&gt;</span> Js.Nullable.t(string);</code></dt><dd><p>`charAtNullable(n, str)` returns `Js.Nullable.return(chStr)`, where `chStr` is a string consisting of the character at location `n` in the string. The first character in a string has position zero.</p><p>If `n` is out of bounds, `charAtNullable()` returns `Js.Nullable.undefined`.</p><pre><code class="ml">charAtNullable(0, &quot;abc&quot;) == Js.Nullable.return(&quot;a&quot;);
charAtNullable(2, &quot;abc&quot;) == Js.Nullable.return(&quot;c&quot;);
charAtNullable(1, {js|대한민국|js}) == Js.Nullable.return({js|한|js});
charAtNullable(-1, &quot;abc&quot;) == Js.Nullable.undefined;
charAtNullable(3, &quot;abc&quot;) == Js.Nullable.undefined;</code></pre></dd></dl><dl><dt class="spec value" id="val-charAtOrThrow"><a href="#val-charAtOrThrow" class="anchor"></a><code><span class="keyword">let</span> charAtOrThrow: int <span>=&gt;</span> string <span>=&gt;</span> string;</code></dt><dd><p>`charAtOrThrow(n, str)` returns a string consisting of the character at location `n` in the string. The first character in a string has position zero.</p><p>If `n` is out of bounds, `charAtOrThrow()` throws a `RangeError`.</p><pre><code class="ml">charAtOrThrow(0, &quot;abc&quot;) == &quot;a&quot;;
charAtOrThrow(2, &quot;abc&quot;) == &quot;c&quot;;
charAtOrThrow(1, {js|대한민국|js}) == {js|한|js};
try (charAtOrThrow(-1, &quot;abc&quot;)) {
  | Js.Exn.Error(_) =&gt; &quot;Invalid index&quot;
} == &quot;Invalid index&quot;;</code></pre></dd></dl><dl><dt class="spec value" id="val-toList"><a href="#val-toList" class="anchor"></a><code><span class="keyword">let</span> toList: string <span>=&gt;</span> list(string);</code></dt><dd><p>`toList(str)` creates a list with one character of `str` per element.</p><pre><code class="ml">toList(&quot;abc&quot;) == [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];
toList({js|日本|js}) == [{js|日|js}, {js|本|js}];
toList(&quot;&quot;) == [];</code></pre></dd></dl><dl><dt class="spec value" id="val-toArray"><a href="#val-toArray" class="anchor"></a><code><span class="keyword">let</span> toArray: string <span>=&gt;</span> array(string);</code></dt><dd><p>`toArray(str)` creates an array with one character of `str` per element.</p><pre><code class="ml">toArray(&quot;abc&quot;) == [|&quot;a&quot;, &quot;b&quot;, &quot;c&quot;|];
toArray({js|日本|js}) == [|{js|日|js}, {js|本|js}|];
toArray(&quot;&quot;) == [| |];</code></pre></dd></dl><dl><dt class="spec value" id="val-foldLeft"><a href="#val-foldLeft" class="anchor"></a><code><span class="keyword">let</span> foldLeft: <span>(<span class="type-var">'b</span> <span>=&gt;</span> string <span>=&gt;</span> <span class="type-var">'b</span>)</span> <span>=&gt;</span> <span class="type-var">'b</span> <span>=&gt;</span> string <span>=&gt;</span> <span class="type-var">'b</span>;</code></dt><dd><p>In `foldLeft(f, init, str)`, `f()` is a function that takes an accumulated value and a string as its arguments. `foldLeft()` starts with `init` as the value of an accumulator. It then calls `f()` repeatedly with each character in the string, moving from left to right, with the result `f(accumulator, chStr)` becoming the new value of the accumulator. When all characters have been processed, the return value is the value of the accumulator.</p><pre><code class="ml">let valueOfChar = (chStr) =&gt; {int_of_float(Js.String.charCodeAt(0, chStr))};
foldLeft( (acc, chStr) =&gt; {acc + valueOfChar(chStr)}, 0, &quot;abc&quot;) == 97 + 98 + 99;
foldLeft( (acc, chStr) =&gt; {acc ++ &quot;-&quot; ++ chStr}, &quot;&quot;, &quot;abc&quot;) == &quot;-a-b-c&quot;;</code></pre></dd></dl><dl><dt class="spec value" id="val-foldRight"><a href="#val-foldRight" class="anchor"></a><code><span class="keyword">let</span> foldRight: <span>(string <span>=&gt;</span> <span class="type-var">'b</span> <span>=&gt;</span> <span class="type-var">'b</span>)</span> <span>=&gt;</span> <span class="type-var">'b</span> <span>=&gt;</span> string <span>=&gt;</span> <span class="type-var">'b</span>;</code></dt><dd><p>In `foldRight(f, init, str)`, `f()` is a function that takes a string and an accumulator as its arguments. `foldRight()` starts with `init` as the value of an accumulator. It then calls `f()` repeatedly with each character in the string, moving from right to left, with the result `f(chStr, accumulator)` becoming the new value of the accumulator. When all characters have been processed, the return value is the value of the accumulator.</p><pre><code class="ml">let valueOfChar = (chStr) =&gt; {int_of_float(Js.String.charCodeAt(0, chStr))};
foldRight( (chStr, acc) =&gt; {acc + valueOfChar(chStr)}, 0, &quot;abc&quot;) == 97 + 98 + 99;
foldRight( (chStr, acc) =&gt; {acc ++ &quot;-&quot; ++ chStr}, &quot;&quot;, &quot;abc&quot;) == &quot;-c-b-a&quot;;</code></pre></dd></dl><dl><dt class="spec value" id="val-show"><a href="#val-show" class="anchor"></a><code><span class="keyword">let</span> show: string <span>=&gt;</span> string;</code></dt><dd><p>* Show function for string (identity)</p></dd></dl><dl><dt class="spec module" id="module-Show"><a href="#module-Show" class="anchor"></a><code><span class="keyword">module</span> Show: BsBastet.Interface.SHOW <span class="keyword">with</span> <span class="keyword">type</span> <a href="#module-Show">Show</a>.t = string;</code></dt><dd><p>* SHOW module for string</p></dd></dl><dl><dt class="spec value" id="val-eq"><a href="#val-eq" class="anchor"></a><code><span class="keyword">let</span> eq: string <span>=&gt;</span> string <span>=&gt;</span> bool;</code></dt><dd><p>`eq(s1, s2)` is a synonym for `s1 == s2`</p></dd></dl><div class="spec module" id="module-Eq"><a href="#module-Eq" class="anchor"></a><code><span class="keyword">module</span> Eq: BsBastet.Interface.EQ <span class="keyword">with</span> <span class="keyword">type</span> <a href="#module-Eq">Eq</a>.t = string;</code></div><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> { ... }<span class="keyword">;</span></code></span></summary><dl><dt class="spec value" id="val-eqWithConversion"><a href="#val-eqWithConversion" class="anchor"></a><code><span class="keyword">let</span> eqWithConversion: <span>(<span class="type-var">'b</span> <span>=&gt;</span> <a href="#module-Eq">Eq</a>.t)</span> <span>=&gt;</span> Relude_Eq.eq(<span class="type-var">'b</span>);</code></dt><dt class="spec value" id="val-notEq"><a href="#val-notEq" class="anchor"></a><code><span class="keyword">let</span> notEq: Relude_Eq.eq(<a href="#module-Eq">Eq</a>.t);</code></dt><dt class="spec value" id="val-eqInverted"><a href="#val-eqInverted" class="anchor"></a><code><span class="keyword">let</span> eqInverted: Relude_Eq.eq(<a href="#module-Eq">Eq</a>.t);</code></dt></dl><div class="spec module" id="module-EqInverted"><a href="#module-EqInverted" class="anchor"></a><code><span class="keyword">module</span> <a href="EqInverted">EqInverted</a>: { ... };</code></div><div class="spec module-type" id="module-type-EQ_BY_F"><a href="#module-type-EQ_BY_F" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-EQ_BY_F">EQ_BY_F</a> =  (<a href="module-type-EQ_BY_F/argument-1-A">A</a>: { ... }) <span>=&gt;</span> { ... };</code></div><div class="spec module" id="module-EqBy"><a href="#module-EqBy" class="anchor"></a><code><span class="keyword">module</span> <a href="EqBy">EqBy</a>:  (<a href="EqBy/argument-1-A">A</a>: { ... }) <span>=&gt;</span> { ... };</code></div></details></div></div></div><dl><dt class="spec value" id="val-compare"><a href="#val-compare" class="anchor"></a><code><span class="keyword">let</span> compare: BsBastet.String.Ord.t <span>=&gt;</span> BsBastet.String.Ord.t <span>=&gt;</span> BsBastet.Interface.ordering;</code></dt><dd><p>* Compares two strings</p></dd></dl><div class="spec module" id="module-Ord"><a href="#module-Ord" class="anchor"></a><code><span class="keyword">module</span> Ord: BsBastet.Interface.ORD <span class="keyword">with</span> <span class="keyword">type</span> <a href="#module-Ord">Ord</a>.t = string;</code></div><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> { ... }<span class="keyword">;</span></code></span></summary><dl><dt class="spec value" id="val-compareWithConversion"><a href="#val-compareWithConversion" class="anchor"></a><code><span class="keyword">let</span> compareWithConversion: <span>(<span class="type-var">'b</span> <span>=&gt;</span> <a href="#module-Ord">Ord</a>.t)</span> <span>=&gt;</span> Relude_Ord.compare(<span class="type-var">'b</span>);</code></dt><dt class="spec value" id="val-compareReversed"><a href="#val-compareReversed" class="anchor"></a><code><span class="keyword">let</span> compareReversed: Relude_Ord.compare(<a href="#module-Ord">Ord</a>.t);</code></dt></dl><div class="spec module" id="module-OrdReversed"><a href="#module-OrdReversed" class="anchor"></a><code><span class="keyword">module</span> <a href="OrdReversed">OrdReversed</a>: { ... };</code></div><dl><dt class="spec value" id="val-compareAsInt"><a href="#val-compareAsInt" class="anchor"></a><code><span class="keyword">let</span> compareAsInt: <a href="#module-Ord">Ord</a>.t <span>=&gt;</span> <a href="#module-Ord">Ord</a>.t <span>=&gt;</span> int;</code></dt><dt class="spec value" id="val-min"><a href="#val-min" class="anchor"></a><code><span class="keyword">let</span> min: <a href="#module-Ord">Ord</a>.t <span>=&gt;</span> <a href="#module-Ord">Ord</a>.t <span>=&gt;</span> <a href="#module-Ord">Ord</a>.t;</code></dt><dt class="spec value" id="val-max"><a href="#val-max" class="anchor"></a><code><span class="keyword">let</span> max: <a href="#module-Ord">Ord</a>.t <span>=&gt;</span> <a href="#module-Ord">Ord</a>.t <span>=&gt;</span> <a href="#module-Ord">Ord</a>.t;</code></dt><dt class="spec value" id="val-lessThan"><a href="#val-lessThan" class="anchor"></a><code><span class="keyword">let</span> lessThan: <a href="#module-Ord">Ord</a>.t <span>=&gt;</span> <a href="#module-Ord">Ord</a>.t <span>=&gt;</span> bool;</code></dt><dt class="spec value" id="val-lt"><a href="#val-lt" class="anchor"></a><code><span class="keyword">let</span> lt: <a href="#module-Ord">Ord</a>.t <span>=&gt;</span> <a href="#module-Ord">Ord</a>.t <span>=&gt;</span> bool;</code></dt><dt class="spec value" id="val-lessThanOrEq"><a href="#val-lessThanOrEq" class="anchor"></a><code><span class="keyword">let</span> lessThanOrEq: <a href="#module-Ord">Ord</a>.t <span>=&gt;</span> <a href="#module-Ord">Ord</a>.t <span>=&gt;</span> bool;</code></dt><dt class="spec value" id="val-lte"><a href="#val-lte" class="anchor"></a><code><span class="keyword">let</span> lte: <a href="#module-Ord">Ord</a>.t <span>=&gt;</span> <a href="#module-Ord">Ord</a>.t <span>=&gt;</span> bool;</code></dt><dt class="spec value" id="val-greaterThan"><a href="#val-greaterThan" class="anchor"></a><code><span class="keyword">let</span> greaterThan: <a href="#module-Ord">Ord</a>.t <span>=&gt;</span> <a href="#module-Ord">Ord</a>.t <span>=&gt;</span> bool;</code></dt><dt class="spec value" id="val-gt"><a href="#val-gt" class="anchor"></a><code><span class="keyword">let</span> gt: <a href="#module-Ord">Ord</a>.t <span>=&gt;</span> <a href="#module-Ord">Ord</a>.t <span>=&gt;</span> bool;</code></dt><dt class="spec value" id="val-greaterThanOrEq"><a href="#val-greaterThanOrEq" class="anchor"></a><code><span class="keyword">let</span> greaterThanOrEq: <a href="#module-Ord">Ord</a>.t <span>=&gt;</span> <a href="#module-Ord">Ord</a>.t <span>=&gt;</span> bool;</code></dt><dt class="spec value" id="val-gte"><a href="#val-gte" class="anchor"></a><code><span class="keyword">let</span> gte: <a href="#module-Ord">Ord</a>.t <span>=&gt;</span> <a href="#module-Ord">Ord</a>.t <span>=&gt;</span> bool;</code></dt><dt class="spec value" id="val-clamp"><a href="#val-clamp" class="anchor"></a><code><span class="keyword">let</span> clamp: <span>min:<a href="#module-Ord">Ord</a>.t</span> <span>=&gt;</span> <span>max:<a href="#module-Ord">Ord</a>.t</span> <span>=&gt;</span> <a href="#module-Ord">Ord</a>.t <span>=&gt;</span> <a href="#module-Ord">Ord</a>.t;</code></dt><dt class="spec value" id="val-between"><a href="#val-between" class="anchor"></a><code><span class="keyword">let</span> between: <span>min:<a href="#module-Ord">Ord</a>.t</span> <span>=&gt;</span> <span>max:<a href="#module-Ord">Ord</a>.t</span> <span>=&gt;</span> <a href="#module-Ord">Ord</a>.t <span>=&gt;</span> bool;</code></dt></dl><div class="spec module" id="module-OrdRingExtensions"><a href="#module-OrdRingExtensions" class="anchor"></a><code><span class="keyword">module</span> <a href="OrdRingExtensions">OrdRingExtensions</a>:  (<a href="OrdRingExtensions/argument-1-R">R</a>: { ... }) <span>=&gt;</span> { ... };</code></div><div class="spec module" id="module-OrdNamed"><a href="#module-OrdNamed" class="anchor"></a><code><span class="keyword">module</span> <a href="OrdNamed">OrdNamed</a>: { ... };</code></div><div class="spec module-type" id="module-type-ORD_BY_F"><a href="#module-type-ORD_BY_F" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-ORD_BY_F">ORD_BY_F</a> =  (<a href="module-type-ORD_BY_F/argument-1-A">A</a>: { ... }) <span>=&gt;</span> { ... };</code></div><div class="spec module" id="module-OrdBy"><a href="#module-OrdBy" class="anchor"></a><code><span class="keyword">module</span> <a href="OrdBy">OrdBy</a>:  (<a href="OrdBy/argument-1-A">A</a>: { ... }) <span>=&gt;</span> { ... };</code></div></details></div></div></div><dl><dt class="spec module" id="module-Map"><a href="#module-Map" class="anchor"></a><code><span class="keyword">module</span> <a href="Map">Map</a>: { ... };</code></dt><dd><p>* Map module with a string key</p></dd></dl><dl><dt class="spec module" id="module-Set"><a href="#module-Set" class="anchor"></a><code><span class="keyword">module</span> <a href="Set">Set</a>: { ... };</code></dt><dd><p>* Set module for strings</p></dd></dl><dl><dt class="spec value" id="val-endsWith"><a href="#val-endsWith" class="anchor"></a><code><span class="keyword">let</span> endsWith: <span>search:string</span> <span>=&gt;</span> string <span>=&gt;</span> bool;</code></dt><dd><p>`endsWith(~search, input)` returns `true` if `input` ends with the characters in `target`; `false` otherwise.</p><p>### Example ```re endsWith(~search=&quot;ing&quot;, &quot;programming&quot;) == true; endsWith(~search=&quot;ing&quot;, &quot;program&quot;) == false; endsWith(~search=&quot;ing&quot;, &quot;in&quot;) == false; endsWith(~search=&quot;&quot;, &quot;everything&quot;) == true; ```</p></dd></dl><dl><dt class="spec value" id="val-startsWith"><a href="#val-startsWith" class="anchor"></a><code><span class="keyword">let</span> startsWith: <span>search:string</span> <span>=&gt;</span> string <span>=&gt;</span> bool;</code></dt><dd><p>`startsWith(~search, input)` returns `true` if `input` starts with the characters in `search`; `false` otherwise.</p><p>### Example ```re startsWith(~search=&quot;pro&quot;, &quot;programming&quot;) == true; startsWith(~search=&quot;pre&quot;, &quot;program&quot;) == false; startsWith(~search=&quot;pre&quot;, &quot;pr&quot;) == false; startsWith(~search=&quot;&quot;, &quot;everything&quot;) == true; ```</p></dd></dl><dl><dt class="spec value" id="val-contains"><a href="#val-contains" class="anchor"></a><code><span class="keyword">let</span> contains: <span>search:string</span> <span>=&gt;</span> string <span>=&gt;</span> bool;</code></dt><dd><p>`contains(~search, input)` returns `true` if `search` appears anywhere in `input`; `false` otherwise.</p><p>### Example ```re contains(~search=&quot;cat&quot;, &quot;catalog&quot;) == true; contains(~search=&quot;cat&quot;, &quot;scatter&quot;) == true; contains(~search=&quot;log&quot;, &quot;catalog&quot;) == true; contains(~search=&quot;ato&quot;, &quot;fraction&quot;) == false; ```</p></dd></dl><dl><dt class="spec value" id="val-indexOf"><a href="#val-indexOf" class="anchor"></a><code><span class="keyword">let</span> indexOf: <span>search:string</span> <span>=&gt;</span> string <span>=&gt;</span> option(int);</code></dt><dd><p>`indexOf(test, str)` returns `Some(n)`, where `n` is the starting position of the first occurrence of `test` within `str`. If `test` is not in `str`, the return value is `None`.</p><p>### Example ```re indexOf(&quot;cat&quot;, &quot;catalog&quot;) == Some(0); indexOf(&quot;cat&quot;, &quot;scatter&quot;) == Some(1); indexOf(&quot;in&quot;, &quot;stringing&quot;) == Some(3); indexOf(&quot;xyz&quot;, &quot;blah&quot;) == None; ```</p></dd></dl><dl><dt class="spec value" id="val-lastIndexOf"><a href="#val-lastIndexOf" class="anchor"></a><code><span class="keyword">let</span> lastIndexOf: <span>search:string</span> <span>=&gt;</span> string <span>=&gt;</span> option(int);</code></dt><dd><p>`lastIndexOf(test, str)` returns `Some(n)`, where `n` is the starting position of the last occurrence of `test` within `str`. If `test` is not in `str`, the return value is `false`.</p><p>### Example ```re lastIndexOf(&quot;cat&quot;, &quot;catalog&quot;) == Some(0); lastIndexOf(&quot;cat&quot;, &quot;scatter&quot;) == Some(1); lastIndexOf(&quot;in&quot;, &quot;stringing&quot;) == Some(6); lastIndexOf(&quot;xyz&quot;, &quot;blah&quot;) == None; ```</p></dd></dl><dl><dt class="spec value" id="val-slice"><a href="#val-slice" class="anchor"></a><code><span class="keyword">let</span> slice: int <span>=&gt;</span> int <span>=&gt;</span> string <span>=&gt;</span> string;</code></dt><dd><p>`slice(n1, n2, str)` returns the substring of `str` starting at character `n1` up to but not including `n2`.</p><p>If either `n1` or `n2` is negative, then it is evaluated as `length(str) - n1` (or `length(str) - n2`).</p><p>If `n2` is greater than the length of `str`, then it is treated as `length(str)`.</p><p>If `n1` is greater than n2`, `slice()` returns the empty string.</p><p>### Example ```re slice(2, 5, &quot;abcdefg&quot;) == &quot;cde&quot;; slice(2, 9, &quot;abcdefg&quot;) == &quot;cdefg&quot;; slice(-4, -2, &quot;abcdefg&quot;) == &quot;de&quot;; slice(5, 1, &quot;abcdefg&quot;) == &quot;&quot;; ```</p></dd></dl><dl><dt class="spec value" id="val-sliceToEnd"><a href="#val-sliceToEnd" class="anchor"></a><code><span class="keyword">let</span> sliceToEnd: int <span>=&gt;</span> string <span>=&gt;</span> string;</code></dt><dd><p>`sliceToEnd(n, str)` returns the substring of `str` starting at character `n` to the end of the string</p><p>If `n` is negative, then it is evaluated as `length(str) - n`.</p><p>If `n` is greater than the length of `str`, then `sliceToEnd()` returns the empty string.</p><p>### Example ```re sliceToEnd(4, &quot;abcdefg&quot;) == &quot;efg&quot;; sliceToEnd(-2, &quot;abcdefg&quot;) == &quot;fg&quot;; sliceToEnd(7, &quot;abcdefg&quot;) == &quot;&quot;; ```</p></dd></dl><dl><dt class="spec value" id="val-splitArray"><a href="#val-splitArray" class="anchor"></a><code><span class="keyword">let</span> splitArray: <span>delimiter:string</span> <span>=&gt;</span> string <span>=&gt;</span> array(string);</code></dt><dd><p>`splitArray(delimiter, str)` splits the given `str` at every occurrence of `delimiter` and returns an array of the resulting substrings.</p><p>### Example ```re splitArray(&quot;-&quot;, &quot;2019-01-02&quot;) == <code>|&quot;2019&quot;, &quot;01&quot;, &quot;02&quot;|</code>; splitArray(&quot;,&quot;, &quot;a,b,,c&quot;) == <code>|&quot;a&quot;, &quot;b&quot;, &quot;&quot;, &quot;c&quot;|</code>; splitArray(&quot;::&quot;, &quot;good::better::best&quot;) == <code>|&quot;good&quot;, &quot;better&quot;, &quot;best&quot;|</code>; splitArray(&quot;;&quot;, &quot;has-no-delimiter&quot;) == <code>|&quot;has-no-delimiter&quot;|</code>; ```</p></dd></dl><dl><dt class="spec value" id="val-splitAsArray"><a href="#val-splitAsArray" class="anchor"></a><code><span class="keyword">let</span> splitAsArray: <span>delimiter:string</span> <span>=&gt;</span> string <span>=&gt;</span> array(string);</code></dt><dd><p>* Alias for splitArray</p></dd></dl><dl><dt class="spec value" id="val-splitList"><a href="#val-splitList" class="anchor"></a><code><span class="keyword">let</span> splitList: <span>delimiter:string</span> <span>=&gt;</span> string <span>=&gt;</span> list(string);</code></dt><dd><p>`splitList(delimiter, str)` splits the given `str` at every occurrence of `delimiter` and returns a list of the resulting substrings.</p><p>### Example ```re splitList(&quot;-&quot;, &quot;2019-01-02&quot;) == <code>&quot;2019&quot;, &quot;01&quot;, &quot;02&quot;</code>; splitList(&quot;,&quot;, &quot;a,b,,c&quot;) == <code>&quot;a&quot;, &quot;b&quot;, &quot;&quot;, &quot;c&quot;</code>; splitList(&quot;::&quot;, &quot;good::better::best&quot;) == <code>&quot;good&quot;, &quot;better&quot;, &quot;best&quot;</code>; splitList(&quot;;&quot;, &quot;has-no-delimiter&quot;) == <code>&quot;has-no-delimiter&quot;</code>; ```</p></dd></dl><dl><dt class="spec value" id="val-splitAsList"><a href="#val-splitAsList" class="anchor"></a><code><span class="keyword">let</span> splitAsList: <span>delimiter:string</span> <span>=&gt;</span> string <span>=&gt;</span> list(string);</code></dt><dd><p>* Alias for splitlist</p></dd></dl><dl><dt class="spec value" id="val-splitAt"><a href="#val-splitAt" class="anchor"></a><code><span class="keyword">let</span> splitAt: int <span>=&gt;</span> string <span>=&gt;</span> <span>(string, string)</span>;</code></dt><dd><p>`splitAt(index, str)` splits the string at the given index, returning a tuple of the parts. If `index` is negative, it is evaluated as `length(str) - index`.</p><p>### Example ```re splitAt(4, &quot;abcdefg&quot;) == (&quot;abcd&quot;, &quot;efg&quot;); splitAt(0, &quot;abcdefg&quot;) == (&quot;&quot;, &quot;abcdefg&quot;); splitAt(7, &quot;abcdefg&quot;) == (&quot;abcdefg&quot;, &quot;&quot;); splitAt(8, &quot;abcdefg&quot;) == (&quot;abcdefg&quot;, &quot;&quot;); splitAt(-3, &quot;abcdefg&quot;) == (&quot;abcd&quot;, &quot;efg&quot;); splitAt(-9, &quot;abcdefg&quot;) == (&quot;&quot;, &quot;abcdefg&quot;); ```</p></dd></dl><dl><dt class="spec value" id="val-mapChars"><a href="#val-mapChars" class="anchor"></a><code><span class="keyword">let</span> mapChars: <span>(string <span>=&gt;</span> string)</span> <span>=&gt;</span> string <span>=&gt;</span> string;</code></dt><dd><p>`mapChars(f, str)` applies the function `f()` to each character of the string, returning a new string.</p><pre><code class="ml">let duplicate = (ch) =&gt; {ch ++ ch};
mapChars(duplicate, &quot;abcde&quot;) == &quot;aabbccddee&quot;;
let capsOnly = (ch) =&gt; {(ch &gt;= &quot;A&quot; &amp;&amp; ch &lt;= &quot;Z&quot;) ? ch : &quot;&quot;};
mapChars(capsOnly, &quot;AbCdE&quot;) == &quot;ACE&quot;;</code></pre></dd></dl><dl><dt class="spec value" id="val-padStart"><a href="#val-padStart" class="anchor"></a><code><span class="keyword">let</span> padStart: <span>targetLength:int</span> <span>=&gt;</span> <span>?&#8288;padWith:string</span> <span>=&gt;</span> string <span>=&gt;</span> string;</code></dt><dd><p>* Pads the string to `targetLength` using `padWith` as a repeated padding on the left side of the `input` string</p></dd></dl><dl><dt class="spec value" id="val-padEnd"><a href="#val-padEnd" class="anchor"></a><code><span class="keyword">let</span> padEnd: <span>targetLength:int</span> <span>=&gt;</span> <span>?&#8288;padWith:string</span> <span>=&gt;</span> string <span>=&gt;</span> string;</code></dt><dd><p>* Pads the string to `targetLength` using `padWith` as a repeated padding on the right side of the `input` string</p></dd></dl><dl><dt class="spec value" id="val-replaceFirst"><a href="#val-replaceFirst" class="anchor"></a><code><span class="keyword">let</span> replaceFirst: <span>search:string</span> <span>=&gt;</span> <span>replaceWith:string</span> <span>=&gt;</span> string <span>=&gt;</span> string;</code></dt><dd><p>`replaceFirst(target, newValue, str)` replaces the first occurrence of `target` with `newValue` in `str`, returning a new string.</p><p>### Example ```re replaceFirst(&quot;in&quot;, &quot;t&quot;, &quot;the rain in spain&quot;) == &quot;the rat in spain&quot;; replaceFirst(&quot;in&quot;, &quot;t&quot;, &quot;playground&quot;) == &quot;playground&quot;; ```</p></dd></dl><dl><dt class="spec value" id="val-replaceEach"><a href="#val-replaceEach" class="anchor"></a><code><span class="keyword">let</span> replaceEach: <span>search:string</span> <span>=&gt;</span> <span>replaceWith:string</span> <span>=&gt;</span> string <span>=&gt;</span> string;</code></dt><dd><p>`replaceEach(target, newValue, str)`replaces each occurrence of `target` with `newValue` in `str`, returning a new string.</p><p>### Example ```re replaceEach(&quot;in&quot;, &quot;t&quot;, &quot;the rain in spain&quot;) == &quot;the rat t spat&quot;; replaceEach(&quot;in&quot;, &quot;t&quot;, &quot;playground&quot;) == &quot;playground&quot;; ```</p></dd></dl><dl><dt class="spec value" id="val-replaceRegex"><a href="#val-replaceRegex" class="anchor"></a><code><span class="keyword">let</span> replaceRegex: <span>search:Js.Re.t</span> <span>=&gt;</span> <span>replaceWith:string</span> <span>=&gt;</span> string <span>=&gt;</span> string;</code></dt><dd><p>`replaceRegex(targetRe, newValue, str)` replaces the matched regular expression `targetRe` with `newValue` in `str`, returning a new string.</p><p>If you use parentheses to store matching substrings in your pattern (as in the last two examples), you may refer to them as `$1`, `$2` etc. in your replacement pattern.</p><p>### Example ```re replaceRegex(<code>%re&quot;/b[aeiou]g/&quot;</code>, &quot;---&quot;, &quot;The big bog bug&quot;) == &quot;The --- bog bug&quot;; replaceRegex(<code>%re&quot;/b[aeiou]g/g&quot;</code>, &quot;---&quot;, &quot;The big bog bug&quot;) == &quot;The --- --- ---&quot;; replaceRegex(<code>%re&quot;/b([aeiou])g/g&quot;</code>, &quot;$1&quot;, &quot;The big bog bug&quot;) == &quot;The i o u&quot;; replaceRegex(<code>%re&quot;/(\\w+)\\s+(\\w+)/&quot;</code>, &quot;$2, $1&quot;, &quot;Clyde Tolson&quot;) == &quot;Tolson, Clyde&quot;; ```</p></dd></dl><dl><dt class="spec value" id="val-removeFirst"><a href="#val-removeFirst" class="anchor"></a><code><span class="keyword">let</span> removeFirst: <span>search:string</span> <span>=&gt;</span> string <span>=&gt;</span> string;</code></dt><dd><p>`removeFirst(target, str)` returns a new string with the first occurrence of `target` removed from `str`.</p><p>### Example ```re removeFirst(&quot;the &quot;, &quot;Paris in the the spring&quot;) == &quot;Paris in the spring&quot;; removeFirst(&quot;the &quot;, &quot;ReasonML is cool&quot;) == &quot;ReasonML is cool&quot;; ```</p></dd></dl><dl><dt class="spec value" id="val-removeEach"><a href="#val-removeEach" class="anchor"></a><code><span class="keyword">let</span> removeEach: <span>search:string</span> <span>=&gt;</span> string <span>=&gt;</span> string;</code></dt><dd><p>`removeEach(target, str)` returns a new string with every occurrence of `target` removed from `str`.</p><p>### Example ```re removeEach(&quot;the &quot;, &quot;Paris in the the spring&quot;) == &quot;Paris in spring&quot;; removeEach(&quot;the &quot;, &quot;ReasonML is cool&quot;) == &quot;ReasonML is cool&quot;; ```</p></dd></dl><dl><dt class="spec value" id="val-fromInt"><a href="#val-fromInt" class="anchor"></a><code><span class="keyword">let</span> fromInt: int <span>=&gt;</span> string;</code></dt><dd><p>`fromInt(n)` returns `n` as a string. This function is a synonym for the built-in `string_of_int()`.</p></dd></dl><dl><dt class="spec value" id="val-toInt"><a href="#val-toInt" class="anchor"></a><code><span class="keyword">let</span> toInt: string <span>=&gt;</span> option(int);</code></dt><dd><p>`toInt(str)` returns `Some(n)` if `str` is a valid string representation of the integer `n`. Otherwise, the return value is `None`.</p><p>### Example ```re toInt(&quot;42&quot;) == Some(42); toInt(&quot;42.3&quot;) == None; toInt(&quot;four&quot;) == None; toInt(&quot;&quot;) == None; ```</p></dd></dl><dl><dt class="spec value" id="val-fromFloat"><a href="#val-fromFloat" class="anchor"></a><code><span class="keyword">let</span> fromFloat: float <span>=&gt;</span> string;</code></dt><dd><p>`fromFloat(x)` converts the value to a string representation. Note that, as in the last examples, it may not be exactly the same as the representation you used when specifying `x`.</p><p>### Example ```re fromFloat(-3.5) == &quot;-3.5&quot;; fromFloat(6.02E23) == &quot;6.02e+23&quot;; fromFloat(1.0e3) == &quot;1000&quot;; ```</p></dd></dl><dl><dt class="spec value" id="val-toFloat"><a href="#val-toFloat" class="anchor"></a><code><span class="keyword">let</span> toFloat: string <span>=&gt;</span> option(float);</code></dt><dd><p>`toFloat(str)` returns `Some(x)` if `str` is a valid string representation of the float value `x`. Otherwise, the return value is `None`.</p><p>### Example ```re toFloat(&quot;42&quot;) == Some(42.0); toFloat(&quot;42.3&quot;) == Some(42.3); toFloat(&quot;123400000&quot;) == Some(123400000.0); toFloat(&quot;four&quot;) == None; toFloat(&quot;&quot;) == None; ```</p></dd></dl></div></body></html>